---
phase: 01-foundation
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - Cargo.lock
  - airev/Cargo.toml
  - airev/src/main.rs
  - airev-mcp/Cargo.toml
  - airev-mcp/src/main.rs
  - airev-core/Cargo.toml
  - airev-core/src/lib.rs
  - airev-core/src/types.rs
  - airev-core/src/db.rs
  - airev-core/src/schema.rs
autonomous: true
requirements:
  - Binary Architecture constraints
  - Rust Stack exact versions
  - SQLite Configuration constraints

must_haves:
  truths:
    - "`cargo build --workspace` completes with zero errors"
    - "The three crates exist: airev, airev-mcp, airev-core"
    - "airev-mcp does not depend on ratatui, crossterm, or any TUI crate"
    - "airev does not depend on rmcp or any MCP crate"
    - "airev-core exposes Session, Comment, Hunk, DiffLine types and an open_db() function"
    - "open_db() sets WAL mode, synchronous=NORMAL, foreign_keys=ON, busy_timeout(10s), and wal_checkpoint(TRUNCATE)"
    - "SQL tables sessions, comments, threads exist after open_db() runs"
  artifacts:
    - path: "Cargo.toml"
      provides: "Workspace root with resolver=3, workspace.dependencies"
      contains: "resolver = \"3\""
    - path: "airev-core/src/db.rs"
      provides: "open_db() async function for WAL-mode SQLite"
      exports: ["open_db"]
    - path: "airev-core/src/schema.rs"
      provides: "SQL DDL for sessions, comments, threads tables"
    - path: "airev-core/src/types.rs"
      provides: "Session, Comment, Hunk, DiffLine structs"
      exports: ["Session", "Comment", "Hunk", "DiffLine"]
  key_links:
    - from: "airev-core/src/db.rs"
      to: "tokio_rusqlite::Connection"
      via: "Connection::open() + call() closure"
      pattern: "conn\\.call\\(\\|db\\|"
    - from: "airev-core/src/db.rs"
      to: "PRAGMA journal_mode=WAL"
      via: "execute_batch inside call() closure"
      pattern: "journal_mode=WAL"
    - from: "airev/Cargo.toml"
      to: "airev-core"
      via: "path dependency"
      pattern: "airev-core"
---

<objective>
Create the Cargo workspace with all three crates and implement airev-core's shared types and database initialization layer.

Purpose: Every subsequent plan depends on this workspace structure compiling. The DB initialization in airev-core is a locked architectural decision — WAL mode, correct pragma sequence, and multi-round schema must be in place from day one.
Output: A compilable workspace; airev-core with Session/Comment/Hunk/DiffLine types, open_db() with full WAL pragma sequence, and CREATE TABLE statements for sessions/comments/threads with the multi-round shape.
</objective>

<execution_context>
@/Users/juliusalexandre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cargo workspace root and three-crate skeleton</name>
  <files>
    Cargo.toml
    airev/Cargo.toml
    airev/src/main.rs
    airev-mcp/Cargo.toml
    airev-mcp/src/main.rs
    airev-core/Cargo.toml
    airev-core/src/lib.rs
  </files>
  <action>
Create the workspace root `Cargo.toml` at the repo root with:
- `[workspace]` section: `resolver = "3"`, `members = ["airev", "airev-mcp", "airev-core"]`
- `[workspace.dependencies]` declaring shared versions:
  - `ratatui = { version = "0.30", features = ["crossterm"] }`
  - `crossterm = { version = "0.29", features = ["event-stream"] }`
  - `tokio = { version = "1.49", features = ["full"] }`
  - `rusqlite = { version = "0.38", features = ["bundled"] }`
  - `tokio-rusqlite = "0.7"`
  - `signal-hook = "0.3"`
  - `futures = "0.3"`
  - `airev-core = { path = "airev-core" }`

Create `airev/Cargo.toml`:
- `[package]` name = "airev", edition = "2021"
- `[dependencies]`: ratatui, crossterm, tokio, signal-hook, futures, airev-core — all via `{ workspace = true }` (inherit version from workspace)
- NO rmcp or MCP dependencies — this crate is TUI only

Create `airev-mcp/Cargo.toml`:
- `[package]` name = "airev-mcp", edition = "2021"
- `[dependencies]`: tokio, rusqlite, airev-core — all via `{ workspace = true }`
- NO ratatui, crossterm, signal-hook, futures — this crate is MCP only
- Add `rmcp = "0.16"` as a direct (non-workspace) dependency since it is not shared

Create `airev-core/Cargo.toml`:
- `[package]` name = "airev-core", edition = "2021"
- `[dependencies]`: rusqlite, tokio-rusqlite, tokio — all via `{ workspace = true }`

Create stub `airev/src/main.rs`:
```rust
fn main() {}
```

Create stub `airev-mcp/src/main.rs`:
```rust
fn main() {}
```

Create `airev-core/src/lib.rs`:
```rust
pub mod db;
pub mod schema;
pub mod types;
```

Run `cargo build --workspace` to confirm the workspace compiles (stub mains are valid).
  </action>
  <verify>
`cargo build --workspace` exits 0 with no errors.
`cargo metadata --no-deps --format-version 1 | grep '"name"'` shows "airev", "airev-mcp", "airev-core".
  </verify>
  <done>
Three crates compile from a single `cargo build --workspace`. No dependency cross-contamination: `cargo tree -p airev | grep rmcp` returns nothing; `cargo tree -p airev-mcp | grep ratatui` returns nothing.
  </done>
</task>

<task type="auto">
  <name>Task 2: airev-core shared types and WAL database initialization</name>
  <files>
    airev-core/src/types.rs
    airev-core/src/db.rs
    airev-core/src/schema.rs
  </files>
  <action>
Create `airev-core/src/types.rs` with the four shared structs:

```rust
/// A review session tied to a specific repository path.
#[derive(Debug, Clone)]
pub struct Session {
    pub id: i64,
    pub repo_path: String,
    pub created_at: i64,      // Unix timestamp
    pub last_opened_at: i64,  // Unix timestamp
}

/// A single comment attached to a hunk or line within a session.
#[derive(Debug, Clone)]
pub struct Comment {
    pub id: i64,
    pub session_id: i64,
    pub thread_id: i64,
    pub file_path: String,
    pub hunk_id: Option<String>,
    pub line_number: Option<i64>,
    pub comment_type: String,  // question/concern/til/suggestion/praise/nitpick
    pub severity: String,      // critical/major/minor/info
    pub body: String,
    pub created_at: i64,
    pub resolved_at: Option<i64>,
}

/// A diff hunk with metadata for display and persistence.
#[derive(Debug, Clone)]
pub struct Hunk {
    pub id: String,           // content-addressed hash of file+range
    pub file_path: String,
    pub old_start: u32,
    pub old_lines: u32,
    pub new_start: u32,
    pub new_lines: u32,
    pub header: String,
    pub body: String,         // raw unified diff text for this hunk
}

/// A single line within a diff hunk with change type.
#[derive(Debug, Clone)]
pub struct DiffLine {
    pub kind: DiffLineKind,
    pub content: String,
    pub old_lineno: Option<u32>,
    pub new_lineno: Option<u32>,
}

/// The type of change for a diff line.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DiffLineKind {
    Added,
    Removed,
    Context,
}
```

Create `airev-core/src/schema.rs` with the SQL DDL constant. Use `CREATE TABLE IF NOT EXISTS` for all tables. Include the multi-round thread shape from day one — do NOT simplify:

```rust
/// SQL DDL for all tables. Applied in open_db() after WAL pragmas.
pub const SCHEMA_SQL: &str = "
    CREATE TABLE IF NOT EXISTS sessions (
        id             INTEGER PRIMARY KEY AUTOINCREMENT,
        repo_path      TEXT    NOT NULL,
        created_at     INTEGER NOT NULL,
        last_opened_at INTEGER NOT NULL
    ) STRICT;

    CREATE TABLE IF NOT EXISTS threads (
        id             INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id     INTEGER NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
        status         TEXT    NOT NULL DEFAULT 'open'
                               CHECK(status IN ('open', 'addressed', 'resolved')),
        round_number   INTEGER NOT NULL DEFAULT 1
    ) STRICT;

    CREATE TABLE IF NOT EXISTS comments (
        id             INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id     INTEGER NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
        thread_id      INTEGER NOT NULL REFERENCES threads(id) ON DELETE CASCADE,
        file_path      TEXT    NOT NULL,
        hunk_id        TEXT,
        line_number    INTEGER,
        comment_type   TEXT    NOT NULL
                               CHECK(comment_type IN ('question','concern','til',
                                                      'suggestion','praise','nitpick')),
        severity       TEXT    NOT NULL
                               CHECK(severity IN ('critical','major','minor','info')),
        body           TEXT    NOT NULL,
        created_at     INTEGER NOT NULL,
        resolved_at    INTEGER
    ) STRICT;
";
```

Create `airev-core/src/db.rs` implementing `open_db()`. Follow the exact pragma sequence from the research:
1. `execute_batch` with `PRAGMA journal_mode=WAL`, `PRAGMA synchronous=NORMAL`, `PRAGMA foreign_keys=ON`
2. `db.busy_timeout(Duration::from_secs(10))` — via the rusqlite Connection method (NOT a PRAGMA string) because busy_timeout is connection-level
3. `PRAGMA wal_checkpoint(TRUNCATE)` run as a plain `execute_batch` (maintenance operation, not a data write)
4. Schema creation using `schema::SCHEMA_SQL` inside a `BEGIN IMMEDIATE` transaction — all write transactions use BEGIN IMMEDIATE per locked requirements

All rusqlite access must go through `tokio_rusqlite::Connection::call()` — never call rusqlite directly outside a `call()` closure.

```rust
use std::time::Duration;
use tokio_rusqlite::Connection;
use crate::schema::SCHEMA_SQL;

/// Opens (or creates) the SQLite database at `path`, configures WAL mode,
/// and applies the schema migrations.
///
/// # Errors
/// Returns an error if the file cannot be opened, WAL cannot be enabled,
/// or schema DDL fails.
pub async fn open_db(path: &str) -> Result<Connection, tokio_rusqlite::Error> {
    let conn = Connection::open(path).await?;

    // Step 1: WAL pragmas — connection-level settings re-applied on every open.
    conn.call(|db| {
        db.execute_batch(
            "PRAGMA journal_mode=WAL;
             PRAGMA synchronous=NORMAL;
             PRAGMA foreign_keys=ON;",
        )?;
        // busy_timeout is set via the Connection method, not a PRAGMA string,
        // to ensure it applies regardless of pragma caching behavior.
        db.busy_timeout(Duration::from_secs(10))?;
        Ok(())
    })
    .await?;

    // Step 2: Checkpoint any leftover WAL from a previous run (maintenance,
    // not a data write — plain execute_batch is appropriate here).
    conn.call(|db| {
        db.execute_batch("PRAGMA wal_checkpoint(TRUNCATE);")?;
        Ok(())
    })
    .await?;

    // Step 3: Apply schema DDL inside a BEGIN IMMEDIATE transaction.
    // All write transactions use BEGIN IMMEDIATE per locked requirements.
    conn.call(|db| {
        let tx = db.transaction_with_behavior(
            rusqlite::TransactionBehavior::Immediate,
        )?;
        tx.execute_batch(SCHEMA_SQL)?;
        tx.commit()?;
        Ok(())
    })
    .await?;

    Ok(conn)
}
```

After writing the files, run `cargo build -p airev-core` to confirm it compiles. Fix any type errors before proceeding.
  </action>
  <verify>
`cargo build -p airev-core` exits 0.
`cargo build --workspace` still exits 0.
`grep -r "journal_mode=WAL" airev-core/src/db.rs` confirms the pragma is present.
`grep -r "busy_timeout" airev-core/src/db.rs` confirms the method call is present.
`grep "TransactionBehavior::Immediate" airev-core/src/db.rs` confirms schema DDL uses BEGIN IMMEDIATE.
`grep "thread_id" airev-core/src/schema.rs` confirms the multi-round thread column exists in comments.
  </verify>
  <done>
airev-core compiles. The Session, Comment, Hunk, DiffLine types are pub-exported from airev-core::types. open_db() in airev-core::db applies the full WAL pragma sequence. The schema DDL is applied inside a BEGIN IMMEDIATE transaction. The sessions, threads, and comments tables are defined with STRICT and the multi-round schema shape (thread_id, round_number, status enum).
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` exits 0 — zero compilation errors across all three crates
2. `cargo tree -p airev | grep rmcp` returns nothing — clean separation
3. `cargo tree -p airev-mcp | grep ratatui` returns nothing — clean separation
4. `cargo test -p airev-core` passes (or no tests exist yet — acceptable at this stage)
5. `grep "resolver = \"3\"" Cargo.toml` confirms workspace resolver version
</verification>

<success_criteria>
The workspace compiles. Three crates exist with correct dependency isolation. airev-core exports shared types and an open_db() function that implements the full WAL pragma sequence, runs wal_checkpoint(TRUNCATE) as a plain maintenance batch, and applies schema DDL inside a BEGIN IMMEDIATE transaction. cargo build --workspace exits 0.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md` following the template at @/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</output>
