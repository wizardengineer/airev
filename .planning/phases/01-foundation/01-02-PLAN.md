---
phase: 01-foundation
plan: "02"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - airev/src/tui.rs
  - airev/src/event.rs
autonomous: true
requirements:
  - Terminal Lifecycle and Safety
  - Event Architecture constraints

must_haves:
  truths:
    - "init_tui() creates a Terminal backed by BufWriter<Stderr> — NOT stdout"
    - "install_panic_hook() chains onto any existing hook and calls restore_tui() first"
    - "restore_tui() disables raw mode and leaves alternate screen before printing panic info"
    - "SIGTERM is detected within 50ms even when rx.recv() is blocking (50ms sleep arm)"
    - "AppEvent covers Key, Resize, Tick, Render, FileChanged, GitResult, DbResult, Quit"
    - "spawn_event_task uses separate tick (250ms) and render (33ms) intervals"
    - "KeyEventKind::Press filter prevents double-fire on Windows"
  artifacts:
    - path: "airev/src/tui.rs"
      provides: "init_tui(), restore_tui(), install_panic_hook(), register_sigterm()"
      exports: ["Tui", "init_tui", "restore_tui", "install_panic_hook", "register_sigterm"]
    - path: "airev/src/event.rs"
      provides: "AppEvent enum, EventHandler, spawn_event_task()"
      exports: ["AppEvent", "EventHandler", "spawn_event_task"]
  key_links:
    - from: "airev/src/tui.rs"
      to: "std::io::stderr"
      via: "BufWriter::new(stderr()) in init_tui()"
      pattern: "BufWriter::new\\(stderr\\(\\)\\)"
    - from: "airev/src/tui.rs"
      to: "panic::set_hook"
      via: "install_panic_hook() chains restore_tui() before original hook"
      pattern: "panic::set_hook"
    - from: "airev/src/event.rs"
      to: "tokio::time::interval"
      via: "two separate intervals in spawn_event_task"
      pattern: "interval\\(Duration"
    - from: "airev/src/event.rs"
      to: "KeyEventKind::Press"
      via: "if key.kind == KeyEventKind::Press check before sending"
      pattern: "KeyEventKind::Press"
---

<objective>
Implement the terminal lifecycle module (tui.rs) and the event bus module (event.rs) for the airev binary.

Purpose: These two modules are the load-bearing walls of the TUI — every subsequent phase adds features on top of them without touching their internals. Getting the stderr backend, panic hook, SIGTERM detection, and event channel exactly right here prevents a class of subtle terminal corruption bugs that are very hard to debug later.
Output: tui.rs with init_tui/restore_tui/install_panic_hook/register_sigterm; event.rs with AppEvent enum, EventHandler struct, and spawn_event_task function with separate tick and render intervals.
</objective>

<execution_context>
@/Users/juliusalexandre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: tui.rs — stderr backend, panic hook, SIGTERM</name>
  <files>airev/src/tui.rs</files>
  <action>
Create `airev/src/tui.rs`. This module owns all terminal lifecycle concerns.

**Type alias:**
```rust
use std::io::{BufWriter, Stderr};
use ratatui::{Terminal, backend::CrosstermBackend};

pub type Tui = Terminal<CrosstermBackend<BufWriter<Stderr>>>;
```

**`init_tui()`** — creates the terminal on stderr (NOT stdout):
```rust
use crossterm::terminal::{enable_raw_mode, EnterAlternateScreen};
use crossterm::execute;
use std::io::{BufWriter, stderr};

pub fn init_tui() -> std::io::Result<Tui> {
    let mut out = BufWriter::new(stderr());
    enable_raw_mode()?;
    execute!(out, EnterAlternateScreen)?;
    Terminal::new(CrosstermBackend::new(out))
}
```

**`restore_tui()`** — idempotent, called at every exit path:
```rust
use crossterm::terminal::{disable_raw_mode, LeaveAlternateScreen};

pub fn restore_tui() -> std::io::Result<()> {
    disable_raw_mode()?;
    execute!(stderr(), LeaveAlternateScreen)?;
    Ok(())
}
```

**`install_panic_hook()`** — must be called BEFORE init_tui(); chains restore_tui() before the original hook so the terminal is usable when the panic message prints:
```rust
use std::panic;

pub fn install_panic_hook() {
    let original_hook = panic::take_hook();
    panic::set_hook(Box::new(move |panic_info| {
        // Restore terminal first so the panic message is readable.
        // Errors from restore_tui() are intentionally ignored here —
        // we're already in a panic, best-effort cleanup only.
        let _ = restore_tui();
        original_hook(panic_info);
    }));
}
```

**`register_sigterm()`** — returns an `Arc<AtomicBool>` set by the signal handler:
```rust
use std::sync::{Arc, atomic::AtomicBool};
use signal_hook::{consts::SIGTERM, flag::register};

pub fn register_sigterm() -> Arc<AtomicBool> {
    let term = Arc::new(AtomicBool::new(false));
    // Safety: signal_hook::flag::register is safe for AtomicBool targets —
    // the handler only calls atomic_store, which is async-signal-safe.
    register(SIGTERM, Arc::clone(&term))
        .expect("Failed to register SIGTERM handler");
    term
}
```

Do NOT add a `Drop` impl on `Tui` — ratatui 0.30 does not auto-restore on Drop (GitHub issue #2087). Explicit restore_tui() calls at every exit path in main.rs (next plan) are the correct approach.

Add a module-level doc comment explaining why stderr is used instead of stdout.
  </action>
  <verify>
`cargo build -p airev` exits 0.
`grep "BufWriter::new(stderr())" airev/src/tui.rs` matches — confirming stderr, not stdout.
`grep "panic::set_hook" airev/src/tui.rs` matches — confirming panic hook installation.
`grep "SIGTERM" airev/src/tui.rs` matches — confirming signal registration.
  </verify>
  <done>
tui.rs compiles. The Tui type alias is CrosstermBackend over BufWriter&lt;Stderr&gt;. init_tui() uses stderr(). install_panic_hook() chains restore_tui() before the original hook. register_sigterm() returns an Arc&lt;AtomicBool&gt; registered against SIGTERM.
  </done>
</task>

<task type="auto">
  <name>Task 2: event.rs — AppEvent enum, EventHandler, spawn_event_task</name>
  <files>airev/src/event.rs</files>
  <action>
Create `airev/src/event.rs`. This module owns the entire event bus.

**`AppEvent` enum** covering all event sources the app will ever handle. Use `#[non_exhaustive]` to allow adding variants in later phases without breaking match exhaustiveness in existing handlers:
```rust
use crossterm::event::KeyEvent;

#[derive(Debug, Clone)]
#[non_exhaustive]
pub enum AppEvent {
    /// A key press from the terminal (KeyEventKind::Press only).
    Key(KeyEvent),
    /// Terminal was resized to (columns, rows).
    Resize(u16, u16),
    /// Logic tick for state updates (4 Hz / 250ms).
    Tick,
    /// Render tick — triggers a terminal.draw() call (30 FPS / 33ms).
    Render,
    /// A watched file changed on disk.
    FileChanged,
    /// Result from the git background thread.
    GitResult,
    /// Result from the database background task.
    DbResult,
    /// Quit signal (from 'q' key or SIGTERM).
    Quit,
}
```

**`EventHandler` struct** — holds the sender and receiver ends of the unbounded channel:
```rust
use tokio::sync::mpsc;

pub struct EventHandler {
    pub tx: mpsc::UnboundedSender<AppEvent>,
    pub rx: mpsc::UnboundedReceiver<AppEvent>,
}

impl EventHandler {
    /// Creates a new EventHandler with a fresh unbounded channel.
    pub fn new() -> Self {
        let (tx, rx) = mpsc::unbounded_channel();
        Self { tx, rx }
    }
}
```

**`spawn_event_task()`** — spawns a single tokio task that drives all event sources. Key implementation requirements:

1. TWO separate intervals: tick at 250ms (4 Hz) and render at 33ms (~30 FPS). They are completely independent — render fires faster than tick.
2. `EventStream::new()` for crossterm events, called `.fuse()` on the future inside the loop (required to avoid polling a completed future in `tokio::select!`).
3. `KeyEventKind::Press` filter — only send `AppEvent::Key` for press events, not release or repeat.
4. `Event::Resize(w, h)` → `AppEvent::Resize(w, h)`.

```rust
use crossterm::event::{Event, EventStream, KeyEventKind};
use futures::{FutureExt, StreamExt};
use std::time::Duration;
use tokio::time::interval;

/// Spawns the background event task that feeds the unified event channel.
///
/// The task runs until the sender is dropped. Tick and render intervals
/// are independent so frame rate and logic rate can be tuned separately.
pub fn spawn_event_task(tx: mpsc::UnboundedSender<AppEvent>) {
    tokio::spawn(async move {
        let mut tick_interval = interval(Duration::from_millis(250));
        let mut render_interval = interval(Duration::from_millis(33));
        let mut reader = EventStream::new();

        loop {
            let tick_tick = tick_interval.tick();
            let render_tick = render_interval.tick();
            let crossterm_event = reader.next().fuse();

            tokio::select! {
                _ = tick_tick => {
                    let _ = tx.send(AppEvent::Tick);
                }
                _ = render_tick => {
                    let _ = tx.send(AppEvent::Render);
                }
                maybe_event = crossterm_event => {
                    match maybe_event {
                        Some(Ok(Event::Key(key))) => {
                            if key.kind == KeyEventKind::Press {
                                let _ = tx.send(AppEvent::Key(key));
                            }
                        }
                        Some(Ok(Event::Resize(w, h))) => {
                            let _ = tx.send(AppEvent::Resize(w, h));
                        }
                        _ => {}
                    }
                }
            }
        }
    });
}
```

Add `airev/src/event.rs` to `airev/src/main.rs` as `mod event;`. The stub main.rs from plan 01 needs `mod tui; mod event;` added so the modules are included in compilation and type-checked.
  </action>
  <verify>
`cargo build -p airev` exits 0.
`grep "KeyEventKind::Press" airev/src/event.rs` matches.
`grep "Duration::from_millis(250)" airev/src/event.rs` matches (tick interval).
`grep "Duration::from_millis(33)" airev/src/event.rs` matches (render interval).
`grep "\.fuse()" airev/src/event.rs` matches (EventStream fuse).
  </verify>
  <done>
event.rs compiles. AppEvent has all 8 variants. EventHandler::new() creates the unbounded channel. spawn_event_task runs two independent intervals (250ms tick, 33ms render) and filters KeyEventKind::Press. The fuse() call is present on the EventStream future.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p airev` exits 0 after both files are written
2. `cargo build --workspace` still exits 0
3. `grep "stderr()" airev/src/tui.rs` — backend is on stderr, not stdout
4. No `impl Drop for Tui` in tui.rs — restore is explicit, not via Drop
5. Two distinct interval durations in event.rs (250ms and 33ms)
</verification>

<success_criteria>
tui.rs and event.rs compile as part of the airev crate. Terminal initialization is on stderr with a manual panic hook. SIGTERM is registered via signal_hook::flag. The event bus uses two independent intervals and filters key events to Press-only.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` following the template at @/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</output>
