---
phase: 01-foundation
plan: "03"
type: execute
wave: 3
depends_on:
  - "01-02"
files_modified:
  - airev/src/main.rs
  - airev/src/ui.rs
autonomous: true
requirements:
  - Terminal Lifecycle and Safety
  - Event Architecture constraints
  - Performance: startup to first frame under 100ms

must_haves:
  truths:
    - "Running airev displays a blank 3-panel layout with borders and exits cleanly on 'q'"
    - "terminal.draw() is called exactly once per AppEvent::Render — never twice per frame"
    - "SIGTERM check happens every 50ms even when no crossterm/tick events arrive"
    - "restore_tui() is called at every exit path: normal quit, Quit event, and panic (via hook)"
    - "DB is opened before the first frame — no loading spinner, no blank wait"
    - "AppEvent::Resize triggers relayout on the next Render"
    - "KeyEventKind::Press 'q' or 'Q' sends AppEvent::Quit and exits"
  artifacts:
    - path: "airev/src/main.rs"
      provides: "tokio::main entry point, event loop, init_tui/spawn_event_task/open_db wiring"
      min_lines: 60
    - path: "airev/src/ui.rs"
      provides: "render() function drawing a blank 3-panel layout"
      exports: ["render"]
  key_links:
    - from: "airev/src/main.rs"
      to: "terminal.draw()"
      via: "single call inside AppEvent::Render arm only"
      pattern: "AppEvent::Render"
    - from: "airev/src/main.rs"
      to: "restore_tui()"
      via: "called after the event loop breaks, before returning"
      pattern: "restore_tui"
    - from: "airev/src/main.rs"
      to: "term_flag.load(Ordering::Relaxed)"
      via: "tokio::select! arm with 50ms sleep driving SIGTERM check"
      pattern: "from_millis\\(50\\)"
    - from: "airev/src/ui.rs"
      to: "ratatui::layout::Layout"
      via: "3-column split with Constraint::Percentage"
      pattern: "Constraint"
---

<objective>
Implement the main event loop in main.rs and a blank 3-panel placeholder UI in ui.rs, completing the runnable TUI shell.

Purpose: This is the integration plan — it wires together all prior work (tui.rs, event.rs, airev-core open_db) into a running application. After this plan, `cargo run -p airev` produces a visible TUI that can be panic-tested and SIGTERM-tested against the phase exit criteria.
Output: A running airev binary showing a blank 3-panel layout; event loop with single terminal.draw() per Render, 50ms SIGTERM detection arm, explicit restore_tui() at all exit paths, and DB opened before first frame.
</objective>

<execution_context>
@/Users/juliusalexandre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: ui.rs — blank 3-panel placeholder layout</name>
  <files>airev/src/ui.rs</files>
  <action>
Create `airev/src/ui.rs`. This module's only job in Phase 1 is to prove the draw loop works with a visible 3-panel layout. No real content — just borders and panel titles.

Use `ratatui::layout::{Constraint, Direction, Layout}` and `ratatui::widgets::Block` with `Borders::ALL`.

```rust
use ratatui::Frame;
use ratatui::layout::{Constraint, Direction, Layout};
use ratatui::widgets::{Block, Borders};

/// Renders the placeholder 3-panel layout.
///
/// Panels (left to right):
///   - File list (25% width)
///   - Diff view (50% width)
///   - Comments (25% width)
///
/// All panels show borders only — no content until subsequent phases.
pub fn render(frame: &mut Frame) {
    let chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(25),
            Constraint::Percentage(50),
            Constraint::Percentage(25),
        ])
        .split(frame.area());

    frame.render_widget(
        Block::default().title("Files").borders(Borders::ALL),
        chunks[0],
    );
    frame.render_widget(
        Block::default().title("Diff").borders(Borders::ALL),
        chunks[1],
    );
    frame.render_widget(
        Block::default().title("Comments").borders(Borders::ALL),
        chunks[2],
    );
}
```

Note: `frame.area()` is the correct call in ratatui 0.30 (not `frame.size()`, which is deprecated). If ratatui 0.30 still has `size()`, prefer `area()` — check the generated docs with `cargo doc -p airev --open` if unsure.
  </action>
  <verify>
`cargo build -p airev` exits 0 after adding `mod ui;` to main.rs.
`grep "frame.area()" airev/src/ui.rs` matches — not the deprecated size().
`grep "Percentage" airev/src/ui.rs` matches — confirms layout constraints.
  </verify>
  <done>
ui.rs compiles. render() takes a &mut Frame and renders 3 bordered panels in a horizontal layout with correct Constraint::Percentage values summing to 100.
  </done>
</task>

<task type="auto">
  <name>Task 2: main.rs — tokio event loop with SIGTERM, DB init, single draw()</name>
  <files>airev/src/main.rs</files>
  <action>
Replace the stub `airev/src/main.rs` with the full event loop. This is the most safety-critical file — follow the requirements exactly.

**Module declarations** at the top:
```rust
mod event;
mod tui;
mod ui;
```

**Startup sequence** (order matters — see Pitfall 6 in RESEARCH.md):
1. `install_panic_hook()` — FIRST, before any other setup, so it's the innermost hook
2. `register_sigterm()` — get the `Arc<AtomicBool>` flag
3. `init_tui()` — enter alternate screen and enable raw mode
4. Create the event channel and `spawn_event_task(tx.clone())`
5. `open_db(".airev/reviews.db")` — open DB before first frame (requirement: no loading spinner)

For the DB path: create the `.airev/` directory if it does not exist using `std::fs::create_dir_all(".airev")` before calling `open_db`.

**Event loop** — the critical constraints:
- `terminal.draw()` called ONLY inside `AppEvent::Render` arm — never elsewhere, never twice
- `AppEvent::Quit` and a SIGTERM check both break the loop
- SIGTERM check must be reliable even when `rx.recv()` would block indefinitely

The SIGTERM problem: `signal_hook::flag::register` sets the `AtomicBool` from the OS signal handler — it does NOT wake a sleeping `rx.recv()`. If no events arrive, the flag is never checked. Solution: add a dedicated `tokio::select!` arm that fires every 50ms as a "heartbeat" to guarantee the SIGTERM flag is polled within 50ms of arrival.

```rust
use std::sync::atomic::Ordering;
use tokio::time::{sleep, Duration};

// Inside the loop:
tokio::select! {
    // Heartbeat: guarantees SIGTERM is checked at least every 50ms,
    // even when no crossterm/tick/render events arrive.
    _ = sleep(Duration::from_millis(50)) => {
        if term_flag.load(Ordering::Relaxed) {
            break;
        }
    }
    maybe_event = rx.recv() => {
        match maybe_event {
            Some(event::AppEvent::Render) => {
                terminal.draw(|frame| ui::render(frame))?;
            }
            Some(event::AppEvent::Key(key)) => {
                use crossterm::event::KeyCode;
                if matches!(key.code, KeyCode::Char('q') | KeyCode::Char('Q')) {
                    break;
                }
            }
            Some(event::AppEvent::Resize(_, _)) => {
                // Resize is handled automatically by ratatui on the next Render —
                // frame.area() returns the new size. No manual action needed here.
                // Log or record for future phases if needed.
            }
            Some(event::AppEvent::Quit) => break,
            None => break,  // Channel closed — event task dropped
            _ => {}
        }
        // Check SIGTERM after every event too, not just on the heartbeat.
        if term_flag.load(Ordering::Relaxed) {
            break;
        }
    }
}
```

**After the loop** — always restore, even if the loop exited via `?` propagation. Since `?` can bypass the restore call if placed after it, structure main to avoid early returns after init_tui(). Use the pattern of calling restore_tui() before returning:

```rust
#[tokio::main]
async fn main() -> std::io::Result<()> {
    tui::install_panic_hook();
    let term_flag = tui::register_sigterm();

    let mut terminal = tui::init_tui()?;

    let handler = event::EventHandler::new();
    event::spawn_event_task(handler.tx.clone());
    let mut rx = handler.rx;  // move out of handler

    std::fs::create_dir_all(".airev")?;
    let _db = airev_core::db::open_db(".airev/reviews.db").await?;

    // Event loop — exits via break (never via ?)
    'event_loop: loop {
        tokio::select! {
            _ = tokio::time::sleep(std::time::Duration::from_millis(50)) => {
                if term_flag.load(std::sync::atomic::Ordering::Relaxed) {
                    break 'event_loop;
                }
            }
            maybe_event = rx.recv() => {
                match maybe_event {
                    Some(event::AppEvent::Render) => {
                        terminal.draw(|frame| ui::render(frame))?;
                    }
                    Some(event::AppEvent::Key(key)) => {
                        use crossterm::event::KeyCode;
                        if matches!(key.code, KeyCode::Char('q') | KeyCode::Char('Q')) {
                            break 'event_loop;
                        }
                    }
                    Some(event::AppEvent::Quit) | None => break 'event_loop,
                    _ => {}
                }
                if term_flag.load(std::sync::atomic::Ordering::Relaxed) {
                    break 'event_loop;
                }
            }
        }
    }

    tui::restore_tui()?;
    Ok(())
}
```

Add `airev-core` as a dependency import: `use airev_core::db::open_db;` — or use the full path. Verify the crate name in airev/Cargo.toml (it is `airev-core` as a package but imported as `airev_core` in Rust).

Run `cargo run -p airev` in a real terminal to confirm the 3-panel layout appears and 'q' exits cleanly. If running in CI/headless environment, `cargo build -p airev` is sufficient for compilation verification.
  </action>
  <verify>
`cargo build -p airev` exits 0.
`grep "terminal.draw" airev/src/main.rs | wc -l` returns 1 — exactly one draw() call.
`grep "restore_tui" airev/src/main.rs` matches — explicit restore after loop.
`grep "from_millis(50)" airev/src/main.rs` matches — SIGTERM heartbeat present.
`grep "open_db" airev/src/main.rs` matches — DB opened before loop.
`grep "create_dir_all" airev/src/main.rs` matches — .airev/ directory created.
  </verify>
  <done>
main.rs compiles and runs. The event loop has a single terminal.draw() call under AppEvent::Render, a 50ms SIGTERM heartbeat arm, explicit restore_tui() after the loop exits, DB opened before first frame, and 'q' exits cleanly. cargo build --workspace exits 0.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` exits 0
2. `cargo run -p airev` (in a real terminal) shows 3 bordered panels: "Files", "Diff", "Comments"
3. Pressing 'q' exits and the terminal is restored (prompt appears normally, no `reset` needed)
4. Exactly one `terminal.draw(` call in main.rs (confirmed by grep count)
5. `restore_tui()` appears after the event loop in main.rs
6. `from_millis(50)` heartbeat sleep appears in the select! block
</verification>

<success_criteria>
`cargo run -p airev` launches a visible 3-panel TUI. Pressing 'q' exits cleanly without terminal corruption. The binary is ready for the panic test and SIGTERM test defined in the phase exit criteria (plan 04).
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md` following the template at @/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</output>
