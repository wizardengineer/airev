---
phase: 02-rendering-skeleton
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - airev/src/app.rs
  - airev/src/ui/mod.rs
  - airev/src/ui/layout.rs
  - airev/src/main.rs
autonomous: true
requirements:
  - Layout

must_haves:
  truths:
    - "TUI renders a 3-panel layout (file list | diff | comments) at 80, 120, and 200 columns without broken borders"
    - "At terminal width < 120 both side panels are collapsed (diff fills full width); at >= 120 all three panels show"
    - "Active panel is highlighted with a distinct border color (border_active vs border_inactive from theme)"
    - "Status bar is always visible as a 1-row strip at the bottom, never blank"
    - "Layout recomputes on every Render event — terminal resize does not require restart"
  artifacts:
    - path: "airev/src/app.rs"
      provides: "AppState, Mode, PanelFocus types and all scroll methods"
      exports: ["AppState", "Mode", "PanelFocus", "KeyAction"]
    - path: "airev/src/ui/layout.rs"
      provides: "compute_layout() returning panel Rects; panel_block() helper; render_status_bar()"
      exports: ["compute_layout", "render_status_bar", "panel_block"]
    - path: "airev/src/ui/mod.rs"
      provides: "render() function replacing ui.rs, calls layout + panel renderers, renders help overlay when mode == HelpOverlay"
      exports: ["render"]
  key_links:
    - from: "airev/src/ui/mod.rs"
      to: "airev/src/ui/layout.rs"
      via: "compute_layout() called inside terminal.draw() closure on every Render"
      pattern: "compute_layout"
    - from: "airev/src/ui/layout.rs"
      to: "airev/src/app.rs"
      via: "AppState.left_pct / center_pct / right_pct / focus read to compute constraints"
      pattern: "state\\.(left_pct|center_pct|right_pct|focus)"
    - from: "airev/src/ui/mod.rs"
      to: "airev/src/app.rs"
      via: "AppState passed as &AppState to render(); viewport heights written back as &mut after layout"
      pattern: "state\\.diff_viewport_height|state\\.file_list_viewport_height|state\\.comments_viewport_height"
---

<objective>
Establish the central AppState type and the responsive 3-panel layout engine.

Purpose: Every subsequent plan in this phase — keybindings, help overlay, and wiring — reads from
and writes to AppState. The layout module is the rendering foundation all panels build on. Doing
these two together avoids a sequenced dependency where layout must wait on a separately-planned
AppState plan.

Output: `app.rs` with all state types and scroll methods; `ui/layout.rs` with the constraint-based
3-panel layout, border merging, and status bar; `ui/mod.rs` with the full render() function wired
to layout; `main.rs` updated with `mod app; mod ui;` declarations and AppState instantiated in
`main()`.
</objective>

<execution_context>
@/Users/juliusalexandre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-rendering-skeleton/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: app.rs — AppState, Mode, PanelFocus, and all scroll methods</name>
  <files>airev/src/app.rs</files>
  <action>
Create `airev/src/app.rs` as a new file. This is pure state — no ratatui imports.

**Enums to define:**

```rust
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
pub enum Mode {
    #[default]
    Normal,
    Insert,
    HelpOverlay,
    ConfirmQuit,
}

#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
pub enum PanelFocus {
    #[default]
    FileList,
    Diff,
    Comments,
}
```

`PanelFocus` needs two methods: `prev()` and `next()` cycling FileList → Diff → Comments → FileList.

**AppState struct:**

```rust
pub struct AppState {
    pub mode: Mode,
    pub focus: PanelFocus,

    // File list panel: ListState from ratatui
    pub file_list_state: ratatui::widgets::ListState,

    // Diff and comments panels: manual u16 offsets for Paragraph::scroll((y, 0))
    pub diff_scroll: u16,
    pub comments_scroll: u16,

    // Viewport heights cached after each render (used for half-page scroll)
    pub diff_viewport_height: u16,
    pub comments_viewport_height: u16,
    pub file_list_viewport_height: u16,

    // Panel width percentages (default: 20 / 55 / 25)
    pub left_pct: u16,
    pub center_pct: u16,
    pub right_pct: u16,

    // Unsaved state guard for quit confirmation
    pub has_unsaved_comments: bool,
}
```

Implement `Default` manually (not derive) so `left_pct = 20`, `center_pct = 55`, `right_pct = 25`.

**Scroll methods on AppState (all respecting focused panel):**

- `scroll_down(&mut self, lines: u16)` — FileList: `file_list_state.scroll_down_by(lines as usize)`; Diff/Comments: saturating_add on the respective `_scroll` field
- `scroll_up(&mut self, lines: u16)` — mirror of above with `scroll_up_by` / `saturating_sub`
- `scroll_top(&mut self)` — FileList: `select_first()`; Diff/Comments: set scroll to 0
- `scroll_bottom(&mut self)` — FileList: `select_last()`; Diff/Comments: set to `u16::MAX` (ratatui clamps silently)
- `half_page_down(&mut self)` — reads the cached viewport height for focused panel, calls `scroll_down(half.max(1))`
- `half_page_up(&mut self)` — same pattern
- `full_page_down(&mut self)` — uses full viewport height
- `full_page_up(&mut self)` — same
- `prev_file(&mut self)` — `file_list_state.scroll_up_by(1)` (moves selection up = previous file)
- `next_file(&mut self)` — `file_list_state.scroll_down_by(1)`
- `prev_hunk(&mut self)` — `diff_scroll = diff_scroll.saturating_sub(5)` (placeholder — Phase 3 replaces with real hunk index)
- `next_hunk(&mut self)` — `diff_scroll = diff_scroll.saturating_add(5)` (placeholder)
- `shrink_diff_panel(&mut self)` — transfers 5% from center to split equally between left and right (clamp center_pct >= 20)
- `grow_diff_panel(&mut self)` — transfers 5% from left/right to center (clamp center_pct <= 80)

Keep each method under 50 lines. Cyclomatic complexity <= 8 per function. All public methods need Google-style docstrings.

Do NOT add the `mod app;` declaration to main.rs yet — Task 2 in this plan handles main.rs changes.
  </action>
  <verify>
cargo build -p airev 2>&1 | grep -E "^error" | wc -l
# Must output 0 (zero compile errors).
# Dead code warnings are expected and acceptable.
  </verify>
  <done>
`airev/src/app.rs` exists with AppState, Mode, PanelFocus, and all scroll method stubs compiling without errors. `cargo build -p airev` exits 0.
  </done>
</task>

<task type="auto">
  <name>Task 2: ui/layout.rs + ui/mod.rs — 3-panel layout, border merging, status bar, full render()</name>
  <files>
    airev/src/ui/layout.rs
    airev/src/ui/mod.rs
    airev/src/main.rs
  </files>
  <action>
**Step 1: Convert ui.rs to ui/ module directory**

The existing `airev/src/ui.rs` must become `airev/src/ui/mod.rs`. Delete `airev/src/ui.rs` and
create the `airev/src/ui/` directory with `mod.rs` inside it. Also create `ui/layout.rs`.

**Step 2: Write `airev/src/ui/layout.rs`**

This module is pure layout arithmetic — no mutable state, no event handling.

```rust
use ratatui::{
    layout::{Constraint, Layout, Margin, Rect, Spacing},
    style::Style,
    symbols::merge::MergeStrategy,
    text::Line,
    widgets::{Block, BorderType, Paragraph},
    Frame,
};
use crate::app::{AppState, Mode, PanelFocus};
use crate::theme::Theme;

/// Returns [left, center, right, status_bar] panel Rects for the current frame.
/// Collapses side panels when terminal width < 120. At < 80, only diff shows.
pub fn compute_layout(frame: &Frame, state: &AppState) -> [Rect; 4] { ... }

/// Builds a bordered Block for a panel. Applies border_active or border_inactive theme color
/// based on focus. Uses Plain border type only (Rounded incompatible with merge_borders).
pub fn panel_block<'a>(
    title: &'a str,
    is_focused: bool,
    theme: &'a Theme,
) -> Block<'a> { ... }

/// Renders the 1-row status bar. Always shows mode text (NORMAL or INSERT). Never blank.
pub fn render_status_bar(frame: &mut Frame, area: Rect, state: &AppState, theme: &Theme) { ... }
```

`compute_layout` implementation details:
- Split `frame.area()` vertically: `[main_area, status_bar]` with `Constraint::Fill(1)` + `Constraint::Length(1)`
- Use `frame.area().layout(Layout::vertical([...]))` returning `[Rect; 2]` (ratatui 0.30 pattern)
- For the horizontal split: if `term_width < 80` → `[Length(0), Fill(1), Length(0)]`; if `< 120` → same; if `>= 120` → `[Percentage(state.left_pct), Percentage(state.center_pct), Percentage(state.right_pct)]`
- Apply `Spacing::Overlap(1)` to the horizontal layout for border merging
- Return `[left, center, right, status_bar]`

`panel_block` implementation details:
- No `BorderType::Rounded` — use `BorderType::Plain` for inactive, `BorderType::Thick` for active
- Call `.merge_borders(MergeStrategy::Fuzzy)` (Fuzzy handles Thick+Plain junctions better than Exact per research pitfall 5)
- Apply `border_style` from theme: `border_active` when `is_focused`, `border_inactive` otherwise

`render_status_bar` implementation details:
- Mode text: `" NORMAL "` for `Normal | ConfirmQuit | HelpOverlay`; `" INSERT "` for `Insert`
- Render as `Paragraph::new(Line::from(mode_span)).style(background_style)` on the status_bar Rect

**Step 3: Write `airev/src/ui/mod.rs`**

Replace the old `ui.rs` content. The `render()` function signature changes to accept `AppState`:

```rust
pub fn render(frame: &mut Frame, state: &mut AppState, theme: &Theme)
```

Inside `render()`:
1. Call `compute_layout(frame, state)` → `[left, center, right, status_bar]`
2. Cache viewport heights: `state.diff_viewport_height = inner_height(center)`, etc., using `area.inner(Margin { vertical: 1, horizontal: 1 }).height` — do this BEFORE rendering panels
3. Render left panel (if `left.width > 0`): render `panel_block("Files", focus == FileList, theme)` as the block, then a placeholder `List` with `[ListItem::new("modified/src/main.rs"), ...]` (3-5 static items) using `frame.render_stateful_widget`
4. Render center panel: render `panel_block("Diff", focus == Diff, theme)` then a `Paragraph` with static placeholder text (10+ lines of fake diff) using `Paragraph::scroll((state.diff_scroll, 0))` in the inner Rect
5. Render right panel (if `right.width > 0`): render `panel_block("Comments", focus == Comments, theme)` then a `Paragraph` with static placeholder text using `Paragraph::scroll((state.comments_scroll, 0))`
6. Call `render_status_bar(frame, status_bar, state, theme)`
7. If `state.mode == Mode::HelpOverlay`: do NOT call help render here — that is added in Plan 02's `ui/help.rs`. For now, leave a `// TODO: render_help_overlay(frame, theme)` comment at this location inside render()

**Step 4: Update `airev/src/main.rs`**

Add `mod app;` and update `mod ui;` (it was `mod ui;` pointing to `ui.rs`; after converting to `ui/mod.rs` this declaration stays identical — Rust resolves both). Add `use crate::app::AppState;` and `use crate::theme::Theme;`. In `main()`, instantiate `let mut state = AppState::default(); let theme = Theme::dark();` before the event loop. Pass `&mut state` and `&theme` to `ui::render()` inside the draw closure. The draw closure call changes from `ui::render(frame)` to `ui::render(frame, &mut state, &theme)`.

Do NOT add keybinding wiring yet — that is Plan 02 + 03.
  </action>
  <verify>
cargo build -p airev 2>&1 | grep "^error" | wc -l
# Must output 0.
# Then launch the binary and confirm visually (manual spot-check):
cargo run -p airev
# Expect: 3-panel TUI visible at default terminal width. Press q to exit cleanly.
# Dead code warnings for AppState fields are expected and fine.
  </verify>
  <done>
`airev/src/ui/layout.rs` and `airev/src/ui/mod.rs` exist. `ui.rs` is deleted. `main.rs` instantiates AppState and passes it to `render()`. `cargo build -p airev` exits 0. Running the binary shows the 3-panel layout with borders and status bar.
  </done>
</task>

</tasks>

<verification>
Run `cargo build -p airev 2>&1 | grep "^error"` — must produce no output (zero errors).

Run `cargo run -p airev` in a terminal. Confirm:
1. Three panels render with bordered regions visible
2. Status bar shows "NORMAL" at the bottom row
3. Press `q` to exit — terminal restores cleanly (no `reset` needed)
4. Resize the terminal window while running — layout recomputes without requiring restart
5. At < 120 columns: side panels collapse, diff fills remaining width
</verification>

<success_criteria>
- `airev/src/app.rs` exists and compiles with AppState, Mode, PanelFocus, all scroll methods
- `airev/src/ui/layout.rs` exists with `compute_layout()`, `panel_block()`, `render_status_bar()`
- `airev/src/ui/mod.rs` exists with `render(frame, state, theme)` signature
- `airev/src/ui.rs` is deleted (replaced by the module directory)
- `cargo build -p airev` exits 0 with zero errors
- Running the binary shows a 3-panel TUI with a NORMAL status bar
</success_criteria>

<output>
After completion, create `.planning/phases/02-rendering-skeleton/02-01-SUMMARY.md` following the template at `/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md`.
</output>
