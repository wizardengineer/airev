---
phase: 02-rendering-skeleton
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - airev/src/ui/keybindings.rs
  - airev/src/ui/help.rs
  - airev/src/ui/mod.rs
autonomous: true
requirements:
  - Navigation and Keybindings
  - Help Overlay

must_haves:
  truths:
    - "All vim navigation keys (j/k/g/G/Ctrl-d/Ctrl-u/Ctrl-f/Ctrl-b) mutate AppState scroll offsets without panicking"
    - "H/L switch panel focus between FileList, Diff, and Comments"
    - "< and > resize the diff panel by 5% per keypress, clamped so no panel disappears"
    - "{ and } step the file list selection; [ and ] adjust the diff scroll by 5 lines (hunk placeholder)"
    - "q returns KeyAction::Quit (no unsaved comments) or sets Mode::ConfirmQuit (unsaved comments)"
    - "? sets Mode::HelpOverlay; Esc and q in HelpOverlay mode return to Normal mode"
    - "Help overlay renders as a centered modal (80% width, 80% height) using Clear + Paragraph inside the single draw closure"
    - "Status bar always shows the current mode string — never blank, never panics on any Mode variant"
  artifacts:
    - path: "airev/src/ui/keybindings.rs"
      provides: "handle_key() dispatching KeyEvent to AppState mutations; KeyAction enum"
      exports: ["handle_key", "KeyAction"]
    - path: "airev/src/ui/help.rs"
      provides: "render_help_overlay() using Clear + Rect::centered + Paragraph"
      exports: ["render_help_overlay"]
    - path: "airev/src/ui/mod.rs"
      provides: "render() updated to call render_help_overlay() when mode == HelpOverlay"
      exports: ["render"]
  key_links:
    - from: "airev/src/ui/keybindings.rs"
      to: "airev/src/app.rs"
      via: "handle_key() takes &mut AppState and calls scroll_down/scroll_up/scroll_top/etc."
      pattern: "state\\.(scroll_down|scroll_up|scroll_top|scroll_bottom|half_page|full_page|prev_|next_|shrink_|grow_)"
    - from: "airev/src/ui/mod.rs"
      to: "airev/src/ui/help.rs"
      via: "render() calls render_help_overlay(frame, theme) when state.mode == Mode::HelpOverlay"
      pattern: "render_help_overlay"
    - from: "airev/src/ui/help.rs"
      to: "ratatui::widgets::Clear"
      via: "frame.render_widget(Clear, area) called before rendering the help Paragraph"
      pattern: "Clear"
---

<objective>
Implement vim keybinding dispatch and the modal help overlay.

Purpose: The keybinding dispatcher is the input layer that connects crossterm key events to
AppState mutations established in Plan 01. The help overlay closes the `?` keybinding loop and
validates that the single-draw-closure modal pattern works correctly before Plan 03 wires
everything into the live event loop.

Output: `ui/keybindings.rs` with `handle_key()` and `KeyAction`; `ui/help.rs` with
`render_help_overlay()`; `ui/mod.rs` updated to call the help overlay renderer.
</objective>

<execution_context>
@/Users/juliusalexandre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-rendering-skeleton/02-RESEARCH.md
@.planning/phases/02-rendering-skeleton/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: ui/keybindings.rs — handle_key() dispatch with all vim bindings</name>
  <files>
    airev/src/ui/keybindings.rs
    airev/src/ui/mod.rs
  </files>
  <action>
**Create `airev/src/ui/keybindings.rs`**

Define a `KeyAction` enum returned by `handle_key()`:

```rust
/// Control-flow signal returned from key dispatch.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum KeyAction {
    /// Continue the event loop normally.
    Continue,
    /// Exit cleanly (no unsaved state).
    Quit,
}
```

Define the top-level dispatcher that routes by mode:

```rust
/// Dispatch a key event to the appropriate mode handler.
/// Mutates `state` in place and returns a `KeyAction` signaling whether to continue or quit.
pub fn handle_key(key: crossterm::event::KeyEvent, state: &mut crate::app::AppState) -> KeyAction {
    match state.mode {
        Mode::HelpOverlay   => handle_help(key, state),
        Mode::ConfirmQuit   => handle_confirm_quit(key, state),
        Mode::Normal        => handle_normal(key, state),
        Mode::Insert        => handle_insert(key, state),
    }
}
```

**`handle_normal` — implement all bindings from the requirements:**

Use `key.code` as the primary match arm and `key.modifiers.contains(KeyModifiers::CONTROL)` as
guards where needed. Follow the exact crossterm pattern from the research (Pattern 4):

| Keybinding | Action |
|------------|--------|
| `j` | `state.scroll_down(1)` |
| `k` | `state.scroll_up(1)` |
| `g` | `state.scroll_top()` |
| `G` | `state.scroll_bottom()` |
| `Ctrl-d` | `state.half_page_down()` |
| `Ctrl-u` | `state.half_page_up()` |
| `Ctrl-f` | `state.full_page_down()` |
| `Ctrl-b` | `state.full_page_up()` |
| `H` (uppercase) | `state.focus = state.focus.prev()` |
| `L` (uppercase) | `state.focus = state.focus.next()` |
| `{` | `state.prev_file()` |
| `}` | `state.next_file()` |
| `[` | `state.prev_hunk()` |
| `]` | `state.next_hunk()` |
| `<` | `state.shrink_diff_panel()` |
| `>` | `state.grow_diff_panel()` |
| `?` | `state.mode = Mode::HelpOverlay` |
| `q` or `Esc` | If `state.has_unsaved_comments`: set `state.mode = Mode::ConfirmQuit`, return `Continue`. Else: return `Quit`. |
| `_` (catch-all) | `KeyAction::Continue` |

**Important implementation notes:**
- `KeyCode::Char('H')` matches uppercase H automatically — crossterm encodes uppercase in the char, no extra `SHIFT` guard needed
- `KeyCode::Char('d') if key.modifiers.contains(KeyModifiers::CONTROL)` for Ctrl-combos
- Split `handle_normal` into a private sub-function `handle_scroll_key` for j/k/g/G/Ctrl-d/u/f/b to stay under 50 lines each
- Ctrl-h/l for panel focus: do NOT implement — the research confirms Ctrl-H conflicts with Backspace on most terminals; uppercase H/L is the primary and only keybinding for focus switching

**`handle_help` — HelpOverlay mode:**

```rust
fn handle_help(key: KeyEvent, state: &mut AppState) -> KeyAction {
    match key.code {
        KeyCode::Char('?') | KeyCode::Esc | KeyCode::Char('q') => {
            state.mode = Mode::Normal;
            KeyAction::Continue
        }
        _ => KeyAction::Continue,
    }
}
```

**`handle_confirm_quit` — ConfirmQuit mode:**

```rust
fn handle_confirm_quit(key: KeyEvent, state: &mut AppState) -> KeyAction {
    match key.code {
        KeyCode::Char('y') | KeyCode::Char('Y') => KeyAction::Quit,
        KeyCode::Char('n') | KeyCode::Char('N') | KeyCode::Esc => {
            state.mode = Mode::Normal;
            KeyAction::Continue
        }
        _ => KeyAction::Continue,
    }
}
```

**`handle_insert` — Insert mode (placeholder):**

```rust
fn handle_insert(key: KeyEvent, state: &mut AppState) -> KeyAction {
    match key.code {
        KeyCode::Esc => { state.mode = Mode::Normal; KeyAction::Continue }
        _ => KeyAction::Continue,
    }
}
```

**Add `pub mod keybindings;` to `airev/src/ui/mod.rs`** (module declaration only — no usage yet; Plan 03 wires `handle_key` into the event loop).

All public symbols require Google-style docstrings. Functions must stay under 50 lines each.
  </action>
  <verify>
cargo build -p airev 2>&1 | grep "^error" | wc -l
# Must output 0.
  </verify>
  <done>
`airev/src/ui/keybindings.rs` exists with `handle_key()`, `KeyAction`, and all mode handlers. `ui/mod.rs` declares `pub mod keybindings`. `cargo build -p airev` exits 0.
  </done>
</task>

<task type="auto">
  <name>Task 2: ui/help.rs — modal help overlay with Clear + Rect::centered</name>
  <files>
    airev/src/ui/help.rs
    airev/src/ui/mod.rs
  </files>
  <action>
**Create `airev/src/ui/help.rs`**

Implement `render_help_overlay(frame: &mut Frame, theme: &Theme)`.

The overlay must:
1. Check terminal width: if `frame.area().width < 60`, render a minimal "? to dismiss" note in the
   status bar area instead (avoid Pitfall 6 — zero-height Rect on narrow terminals). Use
   `frame.area().width >= 60` as the guard.
2. Compute the overlay Rect using `frame.area().centered(Constraint::Percentage(80), Constraint::Percentage(80))`
3. Render `Clear` to erase the background: `frame.render_widget(Clear, overlay_area)`
4. Render a bordered `Block` titled `" Help  — ? or Esc to dismiss "` with `border_style` from `theme.border_active`
5. Render a `Paragraph` with the help text inside the block using `.block(bordered_block).wrap(Wrap { trim: false })`

**Help text content** — build as a `Text` (multi-line `Vec<Line>`) with these sections:

```
Navigation (all modes)
  j / k         Scroll down / up one line
  g / G         Jump to top / bottom
  Ctrl-d / u    Scroll half page down / up
  Ctrl-f / b    Scroll full page down / up
  H / L         Move panel focus left / right

File List
  { / }         Previous / next file

Diff View
  [ / ]         Previous / next hunk (placeholder)
  < / >         Shrink / grow diff panel by 5%

General
  ?             Open / close this help overlay
  q / Esc       Quit (confirms if unsaved comments exist)
```

Use plain `Text::from(vec![...])` — no color styling on the help text for Phase 2 (theme colors
for help overlay text are reserved for Phase 5+ polish). The block border uses `theme.border_active`.

**Add to `airev/src/ui/mod.rs`:**

1. `pub mod help;` declaration
2. Inside `render()`, replace the `// TODO: render_help_overlay(frame, theme)` comment with:
   ```rust
   if state.mode == Mode::HelpOverlay {
       help::render_help_overlay(frame, theme);
   }
   ```
   This call must be AFTER all panel renders but BEFORE the function returns — inside the same
   `terminal.draw()` closure, honoring the single-draw constraint.

All public symbols require Google-style docstrings. Functions must stay under 50 lines each.
  </action>
  <verify>
cargo build -p airev 2>&1 | grep "^error" | wc -l
# Must output 0.
# Manual verification: cargo run -p airev, press ? key.
# Expected: a centered modal box appears with the help text.
# Press ? again or Esc — modal disappears, panels visible again.
# (Note: ? key does not work yet until Plan 03 wires handle_key into the event loop.
#  The render path for HelpOverlay is in place; functional test deferred to Plan 03 checkpoint.)
  </verify>
  <done>
`airev/src/ui/help.rs` exists with `render_help_overlay()`. `ui/mod.rs` declares `pub mod help` and calls `render_help_overlay` when `state.mode == Mode::HelpOverlay`. `cargo build -p airev` exits 0.
  </done>
</task>

</tasks>

<verification>
Run `cargo build -p airev 2>&1 | grep "^error"` — must produce no output.

Confirm module structure:
```
airev/src/ui/
  mod.rs      — render(), pub mod keybindings, pub mod help, pub mod layout
  layout.rs   — compute_layout(), panel_block(), render_status_bar()
  keybindings.rs — handle_key(), KeyAction
  help.rs     — render_help_overlay()
```

Run `grep -n "render_help_overlay" airev/src/ui/mod.rs` — must find the call guarded by `state.mode == Mode::HelpOverlay`.

Run `grep -n "pub mod" airev/src/ui/mod.rs` — must show keybindings, help, and layout declarations.
</verification>

<success_criteria>
- `airev/src/ui/keybindings.rs` exists with all vim bindings in `handle_key()` and mode sub-handlers
- `airev/src/ui/help.rs` exists with `render_help_overlay()` using Clear + Rect::centered
- `ui/mod.rs` updated with module declarations and conditional help render call
- `cargo build -p airev` exits 0 with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-rendering-skeleton/02-02-SUMMARY.md` following the template at `/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md`.
</output>
