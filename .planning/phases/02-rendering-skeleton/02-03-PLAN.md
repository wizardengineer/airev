---
phase: 02-rendering-skeleton
plan: 03
type: execute
wave: 3
depends_on:
  - 02-02
files_modified:
  - airev/src/main.rs
autonomous: false
requirements:
  - Navigation and Keybindings
  - Layout
  - Help Overlay

must_haves:
  truths:
    - "j/k/g/G scroll within the focused panel visibly during a live session"
    - "H/L cycle panel focus with the border color changing on the newly focused panel"
    - "Ctrl-d/Ctrl-u scroll half a page based on the cached viewport height from the previous render"
    - "< and > resize panels with each keypress, clamped so no panel collapses completely"
    - "? opens the help overlay inside the same frame; Esc or ? dismisses it without flicker"
    - "q exits the app cleanly when has_unsaved_comments is false"
    - "At 80, 120, and 200 column widths the layout renders without broken borders"
    - "Resizing the terminal during a running session recomputes layout immediately"
  artifacts:
    - path: "airev/src/main.rs"
      provides: "Event loop with handle_key() wired to AppEvent::Key; KeyAction::Quit breaks the loop"
      exports: []
  key_links:
    - from: "airev/src/main.rs"
      to: "airev/src/ui/keybindings.rs"
      via: "AppEvent::Key arm calls ui::keybindings::handle_key(key_event, &mut state)"
      pattern: "handle_key"
    - from: "airev/src/main.rs"
      to: "airev/src/app.rs"
      via: "AppState instance owned by main(), passed as &mut to handle_key() and as &mut to render()"
      pattern: "AppState"
---

<objective>
Wire handle_key() into the event loop and verify the complete interactive TUI at all target widths.

Purpose: Plans 01 and 02 built all the pieces in isolation. This plan connects them: key events
from the event bus now mutate AppState, which is reflected in the next render frame. The human
checkpoint validates the full interactive experience — scrolling, focus switching, panel resize,
help overlay, and terminal resize — before Phase 2 is declared complete.

Output: `main.rs` updated with keybinding wiring; human checkpoint confirms all Phase 2 exit
criteria pass in a live terminal session.
</objective>

<execution_context>
@/Users/juliusalexandre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-rendering-skeleton/02-RESEARCH.md
@.planning/phases/02-rendering-skeleton/02-01-SUMMARY.md
@.planning/phases/02-rendering-skeleton/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire handle_key() into the main.rs event loop</name>
  <files>airev/src/main.rs</files>
  <action>
Update `airev/src/main.rs` to wire `handle_key()` into the `AppEvent::Key` arm of the event loop.

**Changes required:**

1. Add `use crate::ui::keybindings::{handle_key, KeyAction};` import.

2. In the `AppEvent::Key(key_event)` match arm (which currently does nothing or just `continue`),
   add:
   ```rust
   AppEvent::Key(key_event) => {
       match handle_key(key_event, &mut state) {
           KeyAction::Quit => break,
           KeyAction::Continue => {}
       }
   }
   ```

3. Ensure `AppEvent::Resize` arm triggers a re-render: add `tx.send(AppEvent::Render).ok();` or
   rely on the existing render interval. The current Phase 1 event loop already handles
   `AppEvent::Resize` by calling `terminal.resize()` if available, or at minimum continues to
   the next loop iteration where the next `Render` tick fires. Verify the `AppEvent::Resize` arm
   exists; if it's a catch-all, add an explicit arm that calls `tx.send(AppEvent::Render).ok();`
   to force an immediate redraw after resize. Use `event_handler.tx.clone()` to get a sender
   reference if needed — `EventHandler` exposes `.tx` as a public field per Plan 01-02.

4. Remove any existing `AppEvent::Key` arm that was a no-op placeholder (like `_ => {}` catching
   Key events) from Phase 1. The new arm is the replacement.

5. Verify that `terminal.draw(|frame| { ui::render(frame, &mut state, &theme); })` is the only
   draw call and it passes `&mut state` correctly — this should already be correct from Plan 01.

**No other changes.** Do not touch tui.rs, event.rs, or any other module. The single-draw constraint
(one `terminal.draw()` per `AppEvent::Render` arm) must remain intact — confirm with:
```
grep -n "terminal.draw" airev/src/main.rs | wc -l
# Must output 1
```
  </action>
  <verify>
cargo build -p airev 2>&1 | grep "^error" | wc -l
# Must output 0.

grep -n "terminal.draw" airev/src/main.rs | wc -l
# Must output 1 (single draw call constraint).

grep -n "handle_key" airev/src/main.rs
# Must show handle_key called in the AppEvent::Key arm.
  </verify>
  <done>
`main.rs` has `handle_key(key_event, &mut state)` in the `AppEvent::Key` arm. `KeyAction::Quit` breaks the loop. `cargo build -p airev` exits 0. Single draw call verified.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Human verification — Phase 2 exit criteria at 80/120/200 columns</name>
  <what-built>
Complete Phase 2 interactive TUI:
- 3-panel layout with responsive collapse at narrow widths
- Vim navigation (j/k/g/G/Ctrl-d/u/Ctrl-f/b) scrolling within the focused panel
- H/L panel focus switching with active panel highlighted
- &lt; / &gt; diff panel resize by 5% per keypress
- { / } file list navigation; [ / ] hunk navigation (placeholder scroll)
- ? help overlay (modal, centered, dismissed with ? or Esc)
- Status bar always showing NORMAL or INSERT
- q exits cleanly
  </what-built>
  <how-to-verify>
Run `cargo run -p airev` to launch the TUI. Perform each check in order:

**Layout at 80 columns:**
1. Resize the terminal to 80 columns (`printf '\e[8;%d;%dt' $ROWS 80` or drag the window).
2. Confirm: only the Diff panel is visible, side panels are collapsed, no broken border characters.

**Layout at 120 columns:**
3. Resize to 120 columns.
4. Confirm: all three panels (Files | Diff | Comments) are visible with clean shared borders.

**Layout at 200 columns:**
5. Resize to 200 columns (or maximise).
6. Confirm: three panels visible, proportions look reasonable (no panel is zero-width).

**Panel focus:**
7. Press `L` — border of the Diff panel should become highlighted (different color or thicker border).
8. Press `L` again — Comments panel highlights.
9. Press `H` — Diff panel highlights again.

**Navigation (j/k/g/G):**
10. Press `j` 5 times — placeholder content in the focused panel scrolls down (or selection moves if on FileList).
11. Press `g` — jumps back to top.
12. Press `G` — jumps to bottom (scroll offset or selection moves to end of placeholder content).

**Half-page scroll:**
13. Press `Ctrl-d` — scroll offset advances by roughly half the visible panel height.
14. Press `Ctrl-u` — scroll returns toward top.

**Panel resize:**
15. Press `>` 3 times — diff panel visibly grows wider; file list and comments shrink.
16. Press `<` 3 times — diff panel shrinks back.

**Help overlay:**
17. Press `?` — a centered modal appears listing all keybindings. It covers the panels but does not corrupt them.
18. Press `?` again — modal disappears, panels visible and intact (no flicker or leftover artifacts).
19. Press `?` again, then press `Esc` — modal disappears.

**Status bar:**
20. Confirm the bottom row always shows `NORMAL` during all of the above steps. It should never be blank.

**Terminal resize during live session:**
21. While the TUI is running, drag the terminal window to a different size.
22. Confirm the layout recomputes immediately without requiring a restart.

**Quit:**
23. Press `q` — terminal restores cleanly (cursor visible, shell prompt appears, no `reset` needed).
  </how-to-verify>
  <resume-signal>
Type "approved" if all 23 checks pass.
Describe any failures specifically (e.g., "step 7 — focus border does not change color") so they can be diagnosed.
  </resume-signal>
  <action>Human runs `cargo run -p airev` and performs the 23 verification steps above.</action>
  <verify>All 23 steps pass. User types "approved".</verify>
  <done>Phase 2 exit criteria confirmed: layout correct at 80/120/200 columns, all keybindings functional, help overlay works, quit restores terminal.</done>
</task>

</tasks>

<verification>
Automated checks (run before the human checkpoint):

```bash
cargo build -p airev 2>&1 | grep "^error" | wc -l
# Must output 0

grep -n "terminal.draw" airev/src/main.rs | wc -l
# Must output 1

grep -n "handle_key" airev/src/main.rs
# Must show at least one match in the AppEvent::Key arm

grep -rn "render_help_overlay" airev/src/ui/mod.rs
# Must find the conditional call guarded by state.mode == Mode::HelpOverlay
```
</verification>

<success_criteria>
- `main.rs` calls `handle_key(key_event, &mut state)` in the `AppEvent::Key` arm
- `KeyAction::Quit` breaks out of the event loop
- `cargo build -p airev` exits 0, single draw call confirmed
- Human checkpoint: all 23 verification steps pass in a live terminal session
- Phase 2 exit criteria met: 80/120/200-column layouts correct; focus, navigation, resize, overlay all functional
</success_criteria>

<output>
After completion, create `.planning/phases/02-rendering-skeleton/02-03-SUMMARY.md` following the template at `/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md`.
</output>
