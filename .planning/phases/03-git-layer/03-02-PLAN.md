---
phase: 03-git-layer
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - airev/src/git/worker.rs
  - airev/src/git/mod.rs
  - airev/src/app.rs
autonomous: true
requirements:
  - Diff View
  - Diff Modes
  - Git Integration

must_haves:
  truths:
    - "git/worker.rs background thread opens Repository inside std::thread::spawn — never moves it across the boundary"
    - "All four diff modes are handled: Unstaged, Staged, CommitRange, BranchComparison"
    - "Syntax highlighting runs in the background thread using syntect LazyLock statics"
    - "AppState has diff_lines: Vec<Line<'static>>, diff_scroll: usize, file_summaries, diff_mode, diff_loading, hunk_offsets, selected_file_index"
    - "AppState scroll methods for Diff panel use usize arithmetic (not u16 saturating_add)"
  artifacts:
    - path: "airev/src/git/worker.rs"
      provides: "git_worker_loop() function owning Repository, handling all 4 diff modes, syntax-highlighting output"
      exports: [git_worker_loop]
    - path: "airev/src/git/mod.rs"
      provides: "AsyncGit struct with new() spawning the worker and request_tx for sending GitRequest"
      exports: [AsyncGit]
    - path: "airev/src/app.rs"
      provides: "Extended AppState with diff_lines, diff_scroll (usize), file_summaries, diff_mode, diff_loading, hunk_offsets, selected_file_index"
  key_links:
    - from: "airev/src/git/mod.rs"
      to: "airev/src/git/worker.rs"
      via: "std::thread::spawn(move || git_worker_loop(path, rx, event_tx))"
      pattern: "git_worker_loop"
    - from: "airev/src/git/worker.rs"
      to: "airev/src/event.rs"
      via: "event_tx.send(AppEvent::GitResult(Box::new(payload)))"
      pattern: "AppEvent::GitResult"
---

<objective>
Implement the git background worker thread (the Repository-owning core of the git layer) and extend AppState with all Phase 3 fields. The worker handles all four diff modes, extracts owned structs from git2 callbacks, runs syntect highlighting, and sends results back via the existing tokio MPSC channel.

Purpose: This is the computation engine of Phase 3. Getting it right before wiring the UI ensures the rendering plans can trust the data shapes. AppState extension here avoids modifying app.rs in multiple plans.

Output: A compiling `git/worker.rs` with real git2 diff extraction and syntect highlighting; `git/mod.rs` with `AsyncGit` facade; extended `AppState` with all diff display fields.
</objective>

<execution_context>
@/Users/juliusalexandre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-git-layer/03-RESEARCH.md
@.planning/phases/03-git-layer/03-01-SUMMARY.md
@airev/src/app.rs
@airev/src/event.rs
@airev/src/git/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement git/worker.rs and git/mod.rs AsyncGit facade</name>
  <files>airev/src/git/worker.rs, airev/src/git/mod.rs</files>
  <action>
    Replace the stub `airev/src/git/worker.rs` with the full implementation.

    **Critical constraints (compiler-enforced):**
    - `git2::Repository` is `!Send` — open it INSIDE `std::thread::spawn`, never pass it in.
    - All data extracted from `git2::DiffHunk` / `git2::DiffLine` must be converted to owned types
      (`String`, `u32`, etc.) inside each `foreach` callback before it returns `true`.
      These types borrow from `Diff` and have lifetimes tied to it.
    - Never call `HighlightLines::highlight_line` in the render closure or main thread.

    **`git/worker.rs` implementation:**

    ```rust
    //! Background thread that owns git2::Repository for its lifetime.
    //!
    //! git2::Repository is !Send — it must be opened inside the thread, not passed in.
    //! All communication is via channels: GitRequest in, AppEvent::GitResult out.

    use std::sync::LazyLock;

    use crossbeam_channel::Receiver;
    use git2::Repository;
    use ratatui::style::{Color, Modifier, Style};
    use ratatui::text::{Line, Span};
    use syntect::easy::HighlightLines;
    use syntect::highlighting::ThemeSet;
    use syntect::parsing::SyntaxSet;
    use syntect_tui::into_span;
    use tokio::sync::mpsc::UnboundedSender;

    use crate::event::AppEvent;
    use crate::git::types::{
        DiffMode, FileSummary, GitRequest, GitResultPayload, OwnedDiffHunk, OwnedDiffLine,
    };

    static PS: LazyLock<SyntaxSet> = LazyLock::new(SyntaxSet::load_defaults_newlines);
    static TS: LazyLock<ThemeSet> = LazyLock::new(ThemeSet::load_defaults);
    ```

    The public `git_worker_loop` function signature:
    ```rust
    pub fn git_worker_loop(
        path: String,
        rx: Receiver<GitRequest>,
        event_tx: UnboundedSender<AppEvent>,
    )
    ```

    Inside `git_worker_loop`:
    1. Touch `*PS` and `*TS` to eagerly initialize LazyLock before processing requests
       (avoids first-request latency — see Pitfall 5 in RESEARCH.md).
    2. Open `Repository::open(&path)` — if it fails, log to stderr and return (the thread
       exits silently; the UI shows no diff content, which is acceptable).
    3. Loop: `for request in rx { ... }` — blocks until next request or channel closes.
    4. Call `handle_request(&repo, request)` to get a `GitResultPayload`.
    5. `let _ = event_tx.send(AppEvent::GitResult(Box::new(payload)));`

    **`handle_request` function** (private, ≤50 lines):
    - Takes `&Repository` and `GitRequest` — returns `GitResultPayload`.
    - Match on `GitRequest::LoadDiff(mode)`:
      - `DiffMode::Unstaged` → `repo.diff_index_to_workdir(None, None)`
      - `DiffMode::Staged` → `repo.head()?.peel_to_commit()?.tree()` then `repo.diff_tree_to_index(Some(&head_tree), None, None)`
      - `DiffMode::BranchComparison` → resolve "main" and "HEAD" to trees, `repo.diff_tree_to_tree(Some(&base), Some(&head), None)`
      - `DiffMode::CommitRange` → only reachable via `GitRequest::LoadDiffRange`; emit empty payload for `LoadDiff(CommitRange)`.
    - Match on `GitRequest::LoadDiffRange { from, to }`:
      - Resolve both to trees, `repo.diff_tree_to_tree(Some(&old_tree), Some(&new_tree), None)`.
    - On any `git2::Error`, log to stderr and return an empty `GitResultPayload`.
    - After getting a `Diff`, call `extract_hunks(&diff)` and `extract_files(&diff)`.
    - Call `highlight_hunks(&hunks, file_extension)` to get highlighted lines + hunk offsets.
    - Return `GitResultPayload { mode, hunks, files, highlighted_lines, hunk_offsets }`.

    **`extract_hunks` function** (private):
    - Calls `diff.foreach(&mut |_, _| true, None, Some(&mut hunk_cb), Some(&mut line_cb))`.
    - Inside `hunk_cb`: push new `OwnedDiffHunk` with header from `String::from_utf8_lossy(hunk.header())`.
    - Inside `line_cb`: push `OwnedDiffLine` to `hunks.last_mut()` with origin from `line.origin()`,
      content from `String::from_utf8_lossy(line.content()).into_owned()`,
      and lineno fields. Always return `true`.

    **`extract_files` function** (private):
    - Calls `diff.print(git2::DiffFormat::NameStatus, |_, _, _| true)` is wrong API —
      instead iterate `diff.deltas()` to get each `DiffDelta`:
      ```rust
      diff.deltas().map(|delta| {
          let path = delta.new_file().path()
              .unwrap_or(std::path::Path::new("unknown"))
              .to_string_lossy().into_owned();
          let status = match delta.status() {
              git2::Delta::Added => 'A',
              git2::Delta::Deleted => 'D',
              git2::Delta::Renamed => 'R',
              _ => 'M',
          };
          FileSummary { path, status, added: 0, removed: 0 }
      }).collect()
      ```
      Note: line counts (added/removed per file) are populated in a second pass inside
      `extract_hunks` if convenient, or left as 0 for Plan 01 (file tree shows path+status,
      line counts are enhancement). Keep it simple — populate from `diff.stats()` aggregate
      if the delta-level API is complex.

    **`highlight_hunks` function** (private, ≤50 lines):
    - Takes `&[OwnedDiffHunk]` and a file extension hint (`&str`).
    - Creates a new `HighlightLines` per file (reset at each hunk boundary is acceptable
      since hunks from the same file share a highlighter, but creating per-hunk is safe
      and simpler — use per-hunk for now).
    - For each hunk:
      - Push a hunk header line styled with Color::Cyan (no syntect needed for `@@` lines).
      - Record the current line index into `hunk_offsets`.
    - For each line in hunk:
      - Determine diff color: `Color::Green` for added (`+`), `Color::Red` for removed (`-`),
        `Color::DarkGray` for context (` `).
      - Strip the origin character from content before passing to syntect:
        `let code = if content.starts_with(['+', '-', ' ']) { &content[1..] } else { &content }`.
      - Call `h.highlight_line(code, &PS)` — wrap in `unwrap_or_default()`.
      - Convert segments: `spans = highlighted.into_iter().filter_map(|s| into_span(s).ok()).collect()`.
      - If spans is empty (plain text or binary), fall back to a single unstyled span.
      - Prepend the origin char as a styled span with the diff color, then add syntect spans.
      - Push `Line::from(spans)` to `highlighted_lines`.
    - Return `(highlighted_lines, hunk_offsets)`.

    **file extension extraction** (helper, 2 lines):
    - Extract from the first `FileSummary.path`: `path.rsplit('.').next().unwrap_or("txt")`.

    **`git/mod.rs`** — replace the stub with the real `AsyncGit` facade:

    ```rust
    //! AsyncGit facade — spawns and communicates with the git background thread.

    pub mod types;
    pub mod worker;

    use crossbeam_channel::{Sender, unbounded};
    use tokio::sync::mpsc::UnboundedSender;

    use crate::event::AppEvent;
    use crate::git::types::GitRequest;

    /// Facade for the git background thread.
    ///
    /// Owns the send-half of the request channel. Drop this to signal the worker to exit.
    pub struct AsyncGit {
        /// Send work requests to the background thread via this sender.
        pub request_tx: Sender<GitRequest>,
    }

    impl AsyncGit {
        /// Spawns the background thread and returns the AsyncGit handle.
        ///
        /// The `event_tx` is cloned and captured by the thread; results arrive as
        /// `AppEvent::GitResult` on the main event channel.
        pub fn new(event_tx: UnboundedSender<AppEvent>, repo_path: String) -> Self {
            let (request_tx, request_rx) = unbounded::<GitRequest>();
            std::thread::spawn(move || {
                worker::git_worker_loop(repo_path, request_rx, event_tx);
            });
            Self { request_tx }
        }

        /// Sends a diff load request to the worker thread.
        ///
        /// Non-blocking. Returns false if the worker thread has exited.
        pub fn load_diff(&self, request: GitRequest) -> bool {
            self.request_tx.send(request).is_ok()
        }
    }
    ```

    After implementation, run `cargo build -p airev`. Address any compiler errors:
    - `E0277 Send` errors → you accidentally tried to move Repository; fix by opening inside thread.
    - `lifetime` errors in foreach callbacks → extract data to owned types before returning.
    - `into_span` type mismatch → check syntect-tui 3.0 API; it returns `Result<Span<'static>, _>`.

    Functions must stay ≤50 lines. Split `handle_request` if it grows: separate `get_diff_for_mode`
    (returns `git2::Diff`) from `process_diff` (extracts hunks/files/highlighting).
  </action>
  <verify>
    `cargo build -p airev` exits 0.
    `cargo check -p airev` shows no E0277 errors.
    Confirm no `unsafe` block exists anywhere in `git/worker.rs` or `git/mod.rs`.
    `grep -r "unsafe" airev/src/git/` must return empty.
  </verify>
  <done>
    git/worker.rs compiles. git/mod.rs exports AsyncGit. No unsafe. Repository is opened inside
    std::thread::spawn — the compiler confirms this is valid (no E0277). All four diff modes have
    handling paths in handle_request.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend AppState with Phase 3 diff display fields</name>
  <files>airev/src/app.rs</files>
  <action>
    Extend `AppState` in `airev/src/app.rs` with the fields needed to display real diff content.

    **New fields to add to AppState struct:**

    ```rust
    use crate::git::types::{DiffMode, FileSummary};

    pub struct AppState {
        // ... existing fields unchanged ...

        // Phase 3: Git Layer fields
        /// Pre-highlighted diff lines from the git background thread (List widget source).
        pub diff_lines: Vec<ratatui::text::Line<'static>>,
        /// Line index offset for the diff panel (usize — supports >65535 line diffs).
        /// NOTE: replaces the old u16 diff_scroll for virtual scrolling via List.
        pub diff_scroll: usize,
        /// File summaries from the most recent git diff (for the file-list panel).
        pub file_summaries: Vec<FileSummary>,
        /// Currently active diff mode (Unstaged by default).
        pub diff_mode: DiffMode,
        /// True while the background thread is computing a diff (shows "Computing diff..." in status bar).
        pub diff_loading: bool,
        /// Line indices of @@ hunk header lines within diff_lines (for [/] hunk navigation).
        pub hunk_offsets: Vec<usize>,
        /// Index of the currently selected file in file_summaries (for file-list → diff jump).
        pub selected_file_index: usize,
        /// Current hunk offset cursor index (index into hunk_offsets, not line number).
        pub hunk_cursor: usize,
    }
    ```

    **IMPORTANT — diff_scroll field change:**
    The existing `pub diff_scroll: u16` field must be renamed/replaced to `pub diff_scroll: usize`.
    The old field was used as `Paragraph::scroll((diff_scroll, 0))`. Phase 3 switches the diff
    panel to a `List` widget with manual slicing (see Plan 03) — the scroll offset is now a `usize`
    line index, not a `u16` paragraph offset.

    After renaming, the existing `scroll_down`, `scroll_up`, `scroll_top`, `scroll_bottom`,
    `half_page_down`, `half_page_up`, `full_page_down`, `full_page_up` methods in AppState that
    use `diff_scroll` as `u16` must be updated to use `usize` arithmetic:
    - Replace `self.diff_scroll.saturating_add(lines)` → `self.diff_scroll.saturating_add(lines as usize)`
    - Replace `self.diff_scroll.saturating_sub(lines)` → `self.diff_scroll.saturating_sub(lines as usize)`
    - Replace `self.diff_scroll = u16::MAX` → `self.diff_scroll = usize::MAX` (Plan 03 render will clamp)
    - The `scroll_down_by` / `scroll_up_by` calls on `ListState` take `u16` — those stay as-is.
    - The Diff arm `self.diff_scroll = 0` stays as-is (0 is valid for both types).

    **Default values** for the new fields (in `impl Default for AppState`):
    ```rust
    diff_lines: Vec::new(),
    diff_scroll: 0,
    file_summaries: Vec::new(),
    diff_mode: DiffMode::default(),  // Unstaged
    diff_loading: false,
    hunk_offsets: Vec::new(),
    selected_file_index: 0,
    hunk_cursor: 0,
    ```

    **Add helper methods** to AppState (each ≤20 lines, with Google-style docstrings):

    ```rust
    /// Applies the received GitResultPayload to AppState.
    ///
    /// Called from the AppEvent::GitResult arm in main.rs. Replaces diff content,
    /// clears the loading flag, and resets scroll to top on mode change.
    pub fn apply_git_result(&mut self, payload: crate::git::types::GitResultPayload) {
        let mode_changed = self.diff_mode != payload.mode;
        self.diff_mode = payload.mode;
        self.file_summaries = payload.files;
        self.diff_lines = payload.highlighted_lines;
        self.hunk_offsets = payload.hunk_offsets;
        self.diff_loading = false;
        if mode_changed {
            self.diff_scroll = 0;
            self.hunk_cursor = 0;
        }
    }

    /// Jumps diff_scroll to the next hunk header (] keybinding).
    ///
    /// Advances hunk_cursor. If already at the last hunk, stays there.
    pub fn next_hunk(&mut self) {
        if self.hunk_offsets.is_empty() { return; }
        self.hunk_cursor = (self.hunk_cursor + 1).min(self.hunk_offsets.len() - 1);
        self.diff_scroll = self.hunk_offsets[self.hunk_cursor];
    }

    /// Jumps diff_scroll to the previous hunk header ([ keybinding).
    ///
    /// Decrements hunk_cursor. If already at the first hunk, stays there.
    pub fn prev_hunk(&mut self) {
        if self.hunk_offsets.is_empty() { return; }
        self.hunk_cursor = self.hunk_cursor.saturating_sub(1);
        self.diff_scroll = self.hunk_offsets[self.hunk_cursor];
    }

    /// Jumps diff view to the selected file (Enter or l on file list).
    ///
    /// Updates selected_file_index and resets diff_scroll to 0.
    pub fn jump_to_selected_file(&mut self) {
        if let Some(idx) = self.file_list_state.selected() {
            self.selected_file_index = idx;
            self.diff_scroll = 0;
            self.hunk_cursor = 0;
            self.focus = crate::app::PanelFocus::Diff;
        }
    }
    ```

    NOTE: The existing `prev_hunk()` and `next_hunk()` stub methods in AppState (which just
    adjusted `diff_scroll` by 5 as placeholders) must be replaced with the real implementations above.

    The `scroll_bottom` method for Diff panel: change `self.diff_scroll = u16::MAX` to
    `self.diff_scroll = self.diff_lines.len().saturating_sub(1)` — this is more precise now that
    we know the total line count.

    Run `cargo build -p airev`. Fix all type mismatch errors caused by the u16→usize change:
    - In `ui/layout.rs` `render_status_bar` if it referenced `state.diff_scroll as u16`, update.
    - In `ui/mod.rs` `render_diff` where `Paragraph::scroll((state.diff_scroll, 0))` is called,
      that will be replaced in Plan 03 — for now, cast: `(state.diff_scroll as u16, 0)`.
  </action>
  <verify>
    `cargo build -p airev` exits 0.
    `grep "diff_scroll" airev/src/app.rs` shows `usize` type, not `u16`.
    `grep "apply_git_result\|next_hunk\|prev_hunk\|jump_to_selected_file" airev/src/app.rs`
    confirms all four methods exist.
    `grep "diff_lines\|file_summaries\|diff_mode\|diff_loading\|hunk_offsets" airev/src/app.rs`
    confirms all new fields exist in the struct and Default impl.
  </verify>
  <done>
    AppState compiles with all Phase 3 fields. diff_scroll is usize. apply_git_result(), next_hunk(),
    prev_hunk(), jump_to_selected_file() methods exist. No u16 diff_scroll references remain
    (or if Paragraph::scroll still uses it temporarily, it uses a `as u16` cast until Plan 03).
  </done>
</task>

</tasks>

<verification>
`cargo build --workspace` exits 0.
`grep -r "unsafe" airev/src/git/` returns empty — no unsafe blocks in git layer.
`cargo check --workspace` shows no Send/Sync violations (E0277).
`grep "diff_scroll: usize" airev/src/app.rs` confirms the type upgrade.
</verification>

<success_criteria>
- git/worker.rs implements git_worker_loop with all 4 diff modes and syntect highlighting
- git/mod.rs exports AsyncGit with new() and load_diff()
- AppState has all 8 new Phase 3 fields including diff_scroll: usize
- apply_git_result(), next_hunk(), prev_hunk(), jump_to_selected_file() in AppState
- cargo build --workspace exits 0, no unsafe blocks, no E0277
</success_criteria>

<output>
After completion, create `.planning/phases/03-git-layer/03-02-SUMMARY.md`
</output>
