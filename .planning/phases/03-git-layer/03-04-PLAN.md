---
phase: 03-git-layer
plan: 04
type: execute
wave: 4
depends_on: [03-03]
files_modified:
  - airev/src/main.rs
  - airev/src/ui/keybindings.rs
  - airev/src/ui/layout.rs
autonomous: true
requirements:
  - Diff Modes
  - File List Panel
  - Diff View

must_haves:
  truths:
    - "main.rs spawns AsyncGit::new() before the event loop and sends an initial LoadDiff(Unstaged) request"
    - "AppEvent::GitResult(payload) arm in main.rs calls state.apply_git_result(*payload)"
    - "Tab keybinding cycles DiffMode in AppState and sends a new GitRequest to AsyncGit"
    - "Status bar shows current DiffMode label and 'Computing diff...' when diff_loading is true"
    - "Enter or l on the file list calls state.jump_to_selected_file() to switch diff focus"
    - "[ and ] keybindings call state.prev_hunk() and state.next_hunk() (already wired in Phase 2 — verify they call the real methods now)"
  artifacts:
    - path: "airev/src/main.rs"
      provides: "AsyncGit spawned at startup; AppEvent::GitResult arm applies payload to state"
      contains: "AsyncGit::new"
    - path: "airev/src/ui/keybindings.rs"
      provides: "Tab diff mode cycle in handle_normal(); Enter/l file-list jump in handle_normal()"
      contains: "jump_to_selected_file"
    - path: "airev/src/ui/layout.rs"
      provides: "render_status_bar shows DiffMode and loading indicator"
      contains: "diff_loading"
  key_links:
    - from: "airev/src/main.rs"
      to: "airev/src/git/mod.rs"
      via: "AsyncGit::new(handler.tx.clone(), repo_path)"
      pattern: "AsyncGit::new"
    - from: "airev/src/main.rs"
      to: "airev/src/app.rs"
      via: "state.apply_git_result(*payload)"
      pattern: "apply_git_result"
    - from: "airev/src/ui/keybindings.rs"
      to: "airev/src/app.rs"
      via: "state.jump_to_selected_file()"
      pattern: "jump_to_selected_file"
---

<objective>
Wire the git background thread into the running application: spawn AsyncGit at startup, handle AppEvent::GitResult to apply diff data to state, add Tab diff-mode cycling keybinding, add Enter/l file-list jump keybinding, and update the status bar to show diff mode and loading state.

Purpose: This plan makes the application actually display real git content. Plans 01-03 built the data pipeline; this plan connects it to the live event loop and user input.

Output: A fully wired main.rs where the diff panel shows real highlighted git output on startup, and the user can switch diff modes and jump between files.
</objective>

<execution_context>
@/Users/juliusalexandre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-git-layer/03-RESEARCH.md
@.planning/phases/03-git-layer/03-03-SUMMARY.md
@airev/src/main.rs
@airev/src/ui/keybindings.rs
@airev/src/ui/layout.rs
@airev/src/app.rs
@airev/src/git/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire AsyncGit into main.rs and handle AppEvent::GitResult</name>
  <files>airev/src/main.rs</files>
  <action>
    Update `airev/src/main.rs` to:

    1. **Detect the repo path** before spawning AsyncGit. Use `git2::Repository::discover(".")` to
       walk parent directories from the current working directory. If no repo found, set
       `repo_path = None` and skip AsyncGit spawn — the TUI works fine without git (diff panel
       shows "No diff loaded"). If found, get the path string from `repo.workdir()` or `repo.path()`.

       ```rust
       // After opening the DB:
       let maybe_repo_path: Option<String> = git2::Repository::discover(".")
           .ok()
           .and_then(|r| {
               r.workdir()
                   .or_else(|| Some(r.path()))
                   .map(|p| p.to_string_lossy().into_owned())
           });
       ```

    2. **Spawn AsyncGit** only if a repo was found. Store it as `Option<crate::git::AsyncGit>`:
       ```rust
       let maybe_git: Option<crate::git::AsyncGit> = maybe_repo_path.map(|path| {
           let git = crate::git::AsyncGit::new(handler.tx.clone(), path);
           // Send the initial diff request immediately.
           state.diff_loading = true;
           git.load_diff(crate::git::types::GitRequest::LoadDiff(
               crate::git::types::DiffMode::Unstaged,
           ));
           git
       });
       ```

    3. **Handle AppEvent::GitResult** in the event loop. Add an explicit arm before the `_ => {}`
       catch-all:

       ```rust
       Some(event::AppEvent::GitResult(payload)) => {
           state.apply_git_result(*payload);
           // Trigger immediate redraw after diff data arrives.
           handler.tx.send(event::AppEvent::Render).ok();
       }
       ```

       Because `AppEvent` is `#[non_exhaustive]`, the existing `_ => {}` arm already handles
       unknown variants. Adding the explicit `GitResult(payload)` arm before `_` takes priority
       for that specific variant. No other match arms need changing.

    4. **Pass `maybe_git` into the keybinding dispatcher** for diff mode switching. Because
       `handle_key` currently only takes `(key, &mut AppState)`, there are two options:
       - Option A (preferred): Store the `git_tx: Option<crossbeam_channel::Sender<GitRequest>>`
         in `AppState` so keybindings.rs can send requests directly.
       - Option B: Add `Option<&AsyncGit>` as a third parameter to `handle_key`.

       Use **Option A**: Add `pub git_tx: Option<crossbeam_channel::Sender<crate::git::types::GitRequest>>`
       to `AppState` (default: `None`). In main.rs, after spawning AsyncGit:
       ```rust
       state.git_tx = maybe_git.as_ref().map(|g| g.request_tx.clone());
       ```
       This way keybindings.rs reads `state.git_tx` without needing an extra parameter.
       Add `use crossbeam_channel::Sender;` and the appropriate type to `app.rs`.

    5. **Add `mod git;`** at the top of main.rs if not already present from Plan 01.

    After changes, `cargo build -p airev` must exit 0. If there are type errors from
    `event::AppEvent::GitResult(payload)` where payload is `Box<GitResultPayload>`:
    - The variant is `GitResult(Box<GitResultPayload>)` — destructure as `GitResult(payload)`,
      then call `state.apply_git_result(*payload)` (dereference the Box).
  </action>
  <verify>
    `cargo build -p airev` exits 0.
    `grep "AsyncGit::new\|apply_git_result\|GitResult(payload)" airev/src/main.rs` shows all three.
    `grep "git_tx" airev/src/app.rs` shows the new field in AppState.
    Run `cargo run -p airev 2>/tmp/airev.log` in a git repository directory — diff panel should
    populate within 1-2 seconds (or immediately on small repos). If the terminal is not in a git
    repo, the "No diff loaded" placeholder should appear (graceful no-repo case).
  </verify>
  <done>
    main.rs spawns AsyncGit when a git repo is detected. Initial LoadDiff(Unstaged) request is sent.
    AppEvent::GitResult arm applies payload to state and triggers a Render event.
    git_tx stored in AppState for keybinding access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add diff mode keybindings, file-list jump, and status bar loading indicator</name>
  <files>airev/src/ui/keybindings.rs, airev/src/ui/layout.rs</files>
  <action>
    **`ui/keybindings.rs` — new keybindings in `handle_normal`:**

    1. **Tab — cycle diff mode:**
       Add a `KeyCode::Tab` arm in `handle_normal` (after the existing scroll key delegation):

       ```rust
       KeyCode::Tab => {
           let next_mode = match state.diff_mode {
               DiffMode::Unstaged => DiffMode::Staged,
               DiffMode::Staged => DiffMode::BranchComparison,
               DiffMode::BranchComparison => DiffMode::CommitRange,
               DiffMode::CommitRange => DiffMode::Unstaged,
           };
           state.diff_mode = next_mode;
           state.diff_loading = true;
           state.diff_scroll = 0;
           if let Some(ref tx) = state.git_tx {
               let _ = tx.send(GitRequest::LoadDiff(next_mode));
           }
           KeyAction::Continue
       }
       ```

       Add the necessary imports at the top of keybindings.rs:
       ```rust
       use crate::git::types::{DiffMode, GitRequest};
       ```

    2. **Enter — jump to file in diff (file list panel):**
       Add a `KeyCode::Enter` arm in the `PanelFocus::FileList` section. Currently `handle_normal`
       handles `{` / `}` for file navigation. Add Enter handling that calls
       `state.jump_to_selected_file()`:

       ```rust
       KeyCode::Enter => {
           state.jump_to_selected_file();
           KeyAction::Continue
       }
       ```

       Place this in the general `handle_normal` fn (not inside a focused-panel guard) or
       add a focused-panel check: `if state.focus == PanelFocus::FileList`. Use whichever
       approach is cleaner given the current code structure.

    3. **`l` — also jumps to file (alternative to Enter):**
       Currently `l` is not assigned in normal mode (focus cycle uses uppercase `L`).
       Add `KeyCode::Char('l')` as an alias for Enter when focused on the file list:

       ```rust
       KeyCode::Char('l') if state.focus == PanelFocus::FileList => {
           state.jump_to_selected_file();
           KeyAction::Continue
       }
       ```

       Use a match guard (`if state.focus == PanelFocus::FileList`) to scope this binding.
       When focused on other panels, `l` should fall through to the default (no-op).

    4. **`[` and `]` — hunk navigation:**
       These were wired in Phase 2 as placeholder methods on AppState. Verify they now call
       the real `prev_hunk()` and `next_hunk()` from Plan 02. If the Phase 2 implementation
       called `self.diff_scroll = self.diff_scroll.saturating_sub/add(5)` directly (as a
       placeholder), they are replaced by the real methods in Plan 02. The keybinding arms
       in keybindings.rs should be calling `state.prev_hunk()` and `state.next_hunk()` —
       confirm this is already the case; if the arms call the old inline logic, update them
       to call the AppState methods.

    Ensure each new match arm returns `KeyAction::Continue` (not `KeyAction::Quit`).
    Function `handle_normal` must stay ≤50 lines — if adding Tab/Enter/l causes it to exceed
    the limit, extract a `handle_file_list_key` private fn (as was done for `handle_scroll_key`
    in Phase 2) that handles file-list-specific keys.

    **`ui/layout.rs` — update `render_status_bar`:**

    Read the current `render_status_bar` implementation. Extend it to include:

    1. **Diff mode label** — show which mode is active in the status bar:
       - `DiffMode::Unstaged` → `"UNSTAGED"`
       - `DiffMode::Staged` → `"STAGED"`
       - `DiffMode::BranchComparison` → `"BRANCH"`
       - `DiffMode::CommitRange` → `"RANGE"`

    2. **Loading indicator** — when `state.diff_loading` is true, append `" | Computing diff..."`.

    3. The status bar currently shows the mode indicator (NORMAL/INSERT). Add the diff mode and
       loading indicator as additional spans in the same `Line`. Example format:
       `NORMAL  |  UNSTAGED  |  Computing diff...`

       Keep the status bar single-line (1 row). Use `Span::styled` with `Color::DarkGray` for
       the diff mode label and `Color::Yellow` for the loading indicator text.

    Add import at top of layout.rs:
    ```rust
    use crate::git::types::DiffMode;
    ```

    The `render_status_bar` function signature already takes `&AppState` — just read
    `state.diff_mode` and `state.diff_loading` from it.

    After all edits, `cargo build -p airev` must exit 0. Spot-check:
    - In a git repo: `cargo run -p airev` → diff panel shows highlighted diff, status bar shows
      "UNSTAGED", Tab key cycles to "STAGED", file list shows changed files.
    - Not in a git repo: same binary shows "No diff loaded" gracefully.
  </action>
  <verify>
    `cargo build -p airev` exits 0.
    `grep "Tab\|jump_to_selected_file\|DiffMode\|diff_loading" airev/src/ui/keybindings.rs`
    shows all new keybindings.
    `grep "diff_loading\|diff_mode\|DiffMode" airev/src/ui/layout.rs` shows status bar additions.
    `grep "Computing diff" airev/src/ui/layout.rs` confirms loading indicator text.
    `wc -l airev/src/ui/keybindings.rs` — handle_normal function is within 50-line limit (use
    `awk` to count lines within the function if needed).
  </verify>
  <done>
    Tab cycles DiffMode and sends GitRequest to background thread. Enter and l on file list call
    jump_to_selected_file(). Status bar shows current DiffMode label and "Computing diff..." when loading.
    cargo build exits 0.
  </done>
</task>

</tasks>

<verification>
`cargo build --workspace` exits 0.
Open the TUI in a git repository: diff panel loads real highlighted content within 1-2s.
Status bar shows `NORMAL | UNSTAGED`.
Press Tab: mode cycles to `STAGED`, loading indicator appears briefly, staged diff loads.
Navigate file list with j/k, press Enter: diff panel jumps to that file.
Press [ and ]: diff scroll jumps between @@ hunk headers.
</verification>

<success_criteria>
- main.rs spawns AsyncGit, sends initial LoadDiff(Unstaged), handles GitResult via apply_git_result
- Tab cycles DiffMode and triggers a new diff load request
- Enter/l on file list calls jump_to_selected_file()
- Status bar shows DiffMode label and loading indicator
- cargo build --workspace exits 0
- TUI shows real diff content in a git repository
</success_criteria>

<output>
After completion, create `.planning/phases/03-git-layer/03-04-SUMMARY.md`
</output>
