---
phase: 04-persistence-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - airev-core/Cargo.toml
  - airev-core/src/schema.rs
  - airev-core/src/types.rs
  - airev-core/src/db.rs
  - airev-core/src/lib.rs
  - Cargo.toml
autonomous: true
requirements:
  - SQLite Persistence
  - DB schema versioning

must_haves:
  truths:
    - "Database schema contains sessions, comments, file_review_state, and threads tables with UUID text primary keys"
    - "schema_version table tracks the current migration level"
    - "migrate() applies v1 DDL inside BEGIN IMMEDIATE when schema_version is below 1"
    - "open_db() calls migrate() automatically so future schema bumps are applied on startup"
    - "All write transactions use BEGIN IMMEDIATE (TransactionBehavior::Immediate)"
    - "Session and Comment types use String IDs (not i64)"
  artifacts:
    - path: "airev-core/src/schema.rs"
      provides: "SCHEMA_VERSION_DDL + SCHEMA_V1_SQL constants and migrate() function"
      contains: "schema_version"
    - path: "airev-core/src/types.rs"
      provides: "Session, Comment, FileReviewState structs with String IDs"
      contains: "pub id: String"
    - path: "airev-core/src/db.rs"
      provides: "open_db(), detect_or_create_session(), toggle_file_reviewed(), load_file_review_state()"
      exports: ["open_db", "detect_or_create_session", "toggle_file_reviewed", "load_file_review_state"]
    - path: "airev-core/Cargo.toml"
      provides: "uuid dependency with v4 feature"
      contains: "uuid"
  key_links:
    - from: "airev-core/src/db.rs"
      to: "airev-core/src/schema.rs"
      via: "migrate() called from open_db()"
      pattern: "crate::schema::migrate"
    - from: "airev-core/src/db.rs"
      to: "airev-core/src/types.rs"
      via: "functions return Session, FileReviewState structs"
      pattern: "crate::types::Session"
---

<objective>
Rewrite airev-core's database layer: new v1 schema with UUID text IDs, schema versioning via
schema_version table, and all DB access functions (session lifecycle, file review toggle, review
state loading) that Phase 4's TUI wiring will call.

Purpose: Establish the finalized multi-round thread schema and DB function signatures that both the
TUI (Phase 4) and MCP server (Phase 7) will build on top of. Every function uses
Connection::call() with BEGIN IMMEDIATE for writes.

Output: Rewritten schema.rs, types.rs, db.rs in airev-core; uuid crate added.
</objective>

<execution_context>
@/Users/juliusalexandre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-persistence-layer/04-RESEARCH.md
@airev-core/src/schema.rs
@airev-core/src/types.rs
@airev-core/src/db.rs
@airev-core/src/lib.rs
@airev-core/Cargo.toml
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite schema.rs with v1 DDL and schema versioning migration</name>
  <files>airev-core/src/schema.rs</files>
  <action>
Completely replace the contents of `airev-core/src/schema.rs`. Remove the old `SCHEMA_SQL` constant.

Add three items:

1. `SCHEMA_VERSION_DDL` constant: `CREATE TABLE IF NOT EXISTS schema_version (version INTEGER NOT NULL) STRICT;`

2. `SCHEMA_V1_SQL` constant containing DDL for four tables (all using `STRICT` mode):
   - `sessions`: `id TEXT PRIMARY KEY` (UUID v4), `repo_path TEXT NOT NULL`, `diff_mode TEXT NOT NULL`, `diff_args TEXT NOT NULL DEFAULT ''`, `created_at INTEGER NOT NULL` (Unix seconds), `updated_at INTEGER NOT NULL` (Unix seconds)
   - `comments`: `id TEXT PRIMARY KEY` (UUID v4), `session_id TEXT NOT NULL REFERENCES sessions(id) ON DELETE CASCADE`, `file_path TEXT NOT NULL`, `line_number INTEGER`, `hunk_offset INTEGER`, `comment_type TEXT NOT NULL CHECK(comment_type IN ('question','concern','til','suggestion','praise','nitpick'))`, `severity TEXT NOT NULL CHECK(severity IN ('critical','major','minor','info'))`, `body TEXT NOT NULL`, `created_at INTEGER NOT NULL`, `resolved_at INTEGER`, `thread_id TEXT REFERENCES threads(id) ON DELETE SET NULL`
   - `file_review_state`: `session_id TEXT NOT NULL REFERENCES sessions(id) ON DELETE CASCADE`, `file_path TEXT NOT NULL`, `reviewed INTEGER NOT NULL DEFAULT 0` (boolean 0/1), `reviewed_at INTEGER`, `PRIMARY KEY (session_id, file_path)`
   - `threads`: `id TEXT PRIMARY KEY` (UUID v4), `session_id TEXT NOT NULL REFERENCES sessions(id) ON DELETE CASCADE`, `status TEXT NOT NULL DEFAULT 'open' CHECK(status IN ('open', 'addressed', 'resolved'))`, `round_number INTEGER NOT NULL DEFAULT 1`

   Note: `threads` table is included now (exit criterion requires `SELECT * FROM threads;` to succeed) but no Phase 4 write path touches it. The `comments` table references `threads(id)` with `ON DELETE SET NULL` so comments can exist without a thread.

3. `migrate()` public function with signature `pub fn migrate(db: &rusqlite::Connection) -> rusqlite::Result<()>`:
   - Execute `SCHEMA_VERSION_DDL` via `db.execute_batch()`
   - Query current version: `SELECT COALESCE(MAX(version), 0) FROM schema_version` with `.unwrap_or(0)` fallback
   - If version < 1: open a transaction with `db.transaction_with_behavior(rusqlite::TransactionBehavior::Immediate)`, execute `SCHEMA_V1_SQL` batch, insert `version = 1` into `schema_version`, commit
   - Return `Ok(())`

Add Google-style docstrings on all public items. Keep `use rusqlite;` import minimal (no wildcards).
  </action>
  <verify>`cargo build -p airev-core 2>&1 | tail -5` shows no errors. `grep -c "SCHEMA_V1_SQL" airev-core/src/schema.rs` returns 1. `grep -c "migrate" airev-core/src/schema.rs` returns at least 2 (definition + docstring). `grep "SCHEMA_SQL" airev-core/src/schema.rs` returns nothing (old constant removed).</verify>
  <done>schema.rs contains SCHEMA_VERSION_DDL, SCHEMA_V1_SQL (4 tables with UUID text IDs, foreign keys, CHECK constraints), and migrate() function. Old SCHEMA_SQL is gone. airev-core compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Update types.rs, add uuid dep, rewrite db.rs with session lifecycle and file review functions</name>
  <files>airev-core/src/types.rs, airev-core/Cargo.toml, Cargo.toml, airev-core/src/db.rs</files>
  <action>
**Step A: Add uuid dependency.**

Add `uuid = { version = "1", features = ["v4"] }` to `[workspace.dependencies]` in the root `Cargo.toml`. Add `uuid = { workspace = true }` to `airev-core/Cargo.toml` under `[dependencies]`.

**Step B: Rewrite types.rs.**

Replace the existing `Session` and `Comment` structs (keep `Hunk`, `DiffLine`, `DiffLineKind` unchanged — they are used by Phase 3 git layer):

```rust
/// A review session tied to a specific repository, diff mode, and arguments.
#[derive(Debug, Clone)]
pub struct Session {
    pub id: String,           // UUID v4 text
    pub repo_path: String,
    pub diff_mode: String,
    pub diff_args: String,
    pub created_at: i64,      // Unix timestamp seconds
    pub updated_at: i64,      // Unix timestamp seconds
}

/// A single comment attached to a hunk or line within a session.
#[derive(Debug, Clone)]
pub struct Comment {
    pub id: String,           // UUID v4 text
    pub session_id: String,
    pub file_path: String,
    pub line_number: Option<i64>,
    pub hunk_offset: Option<i64>,
    pub comment_type: String,
    pub severity: String,
    pub body: String,
    pub created_at: i64,
    pub resolved_at: Option<i64>,
    pub thread_id: Option<String>,
}

/// Per-file reviewed state within a session.
#[derive(Debug, Clone)]
pub struct FileReviewState {
    pub session_id: String,
    pub file_path: String,
    pub reviewed: bool,
    pub reviewed_at: Option<i64>,
}
```

Keep Google-style docstrings on all public items.

**Step C: Rewrite db.rs.**

Replace `open_db()` to call `crate::schema::migrate(db)` instead of the old inline `SCHEMA_SQL` transaction. The new `open_db()` signature stays the same: `pub async fn open_db(path: &str) -> Result<Connection, tokio_rusqlite::Error>`. Structure:
1. `Connection::open(path).await?`
2. First `call()`: WAL pragmas (`journal_mode=WAL`, `synchronous=NORMAL`, `foreign_keys=ON`) + `db.busy_timeout(Duration::from_secs(5))` (note: research says 5s, existing code uses 10s — use 5s per research recommendation to match the pattern for MCP concurrent access)
3. Second `call()`: `PRAGMA wal_checkpoint(TRUNCATE);`
4. Third `call()`: `crate::schema::migrate(db)?; Ok(())`

Add four new public async functions:

1. `detect_or_create_session(conn, repo_path, diff_mode, diff_args) -> Result<Session, tokio_rusqlite::Error>`:
   - Clone all `&str` params to `String` for the `'static + Send` closure bound
   - Inside `conn.call(move |db| { ... })`:
     - Query most recent session: `SELECT id, repo_path, diff_mode, diff_args, created_at, updated_at FROM sessions WHERE repo_path = ?1 AND diff_mode = ?2 AND diff_args = ?3 ORDER BY updated_at DESC LIMIT 1`
     - Use `query_row(...).optional()?` for the Option result
     - If found: update `updated_at` to now via BEGIN IMMEDIATE transaction, return the Session
     - If not found: generate UUID via `uuid::Uuid::new_v4().to_string()`, get now timestamp, INSERT via BEGIN IMMEDIATE transaction, return new Session
   - `.await` the call result

2. `load_file_review_state(conn, session_id) -> Result<Vec<(String, bool)>, tokio_rusqlite::Error>`:
   - Clone session_id for closure
   - Inside `conn.call()`: `SELECT file_path, reviewed FROM file_review_state WHERE session_id = ?1`
   - Use `prepare()` + `query_map()` to collect into `Vec<(String, bool)>`
   - `.await` the result

3. `toggle_file_reviewed(conn, session_id, file_path) -> Result<bool, tokio_rusqlite::Error>`:
   - Clone both `&str` params
   - Inside `conn.call()`:
     - Read current state: `SELECT reviewed FROM file_review_state WHERE session_id = ?1 AND file_path = ?2`, `.unwrap_or(false)` if no row
     - Compute `new_state = !current`
     - Get timestamp for `reviewed_at` (Some(now) if new_state, None otherwise)
     - BEGIN IMMEDIATE transaction
     - Upsert: `INSERT INTO file_review_state (session_id, file_path, reviewed, reviewed_at) VALUES (?1, ?2, ?3, ?4) ON CONFLICT(session_id, file_path) DO UPDATE SET reviewed = excluded.reviewed, reviewed_at = excluded.reviewed_at`
     - Commit, return `new_state`
   - `.await` the result

4. `update_session_timestamp(conn, session_id) -> Result<(), tokio_rusqlite::Error>`:
   - Simple BEGIN IMMEDIATE: `UPDATE sessions SET updated_at = ?1 WHERE id = ?2`
   - Used to touch session on quit (optional, can be called from event loop teardown)

All functions use `use std::time::{SystemTime, UNIX_EPOCH};` for timestamps. All use Google-style docstrings. All write transactions use `TransactionBehavior::Immediate`.

Import `use crate::schema;` and `use crate::types::Session;` at the top. Import `use rusqlite::OptionalExtension;` for `.optional()` on query_row.
  </action>
  <verify>`cargo build -p airev-core 2>&1 | tail -5` shows no errors. `cargo build --workspace 2>&1 | tail -10` — may show warnings in airev crate about changed types (expected — airev uses old Session.id: i64 nowhere directly, but event.rs references DbResult unit variant which still compiles). `grep "pub async fn" airev-core/src/db.rs | wc -l` returns at least 4.</verify>
  <done>types.rs has Session/Comment/FileReviewState with String IDs. db.rs has open_db() calling migrate(), plus detect_or_create_session(), load_file_review_state(), toggle_file_reviewed(), update_session_timestamp(). uuid crate added to workspace. Full workspace builds without errors.</done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds with zero errors
2. `sqlite3 :memory:` can execute the SCHEMA_V1_SQL manually and `SELECT * FROM threads;` succeeds (empty result)
3. `grep -c "TransactionBehavior::Immediate" airev-core/src/db.rs` returns 3+ (one per write function)
4. `grep -c "uuid::Uuid::new_v4" airev-core/src/db.rs` returns at least 1
5. No reference to old `SCHEMA_SQL` constant anywhere: `grep -r "SCHEMA_SQL" airev-core/src/` returns only `SCHEMA_V1_SQL` and `SCHEMA_VERSION_DDL`
</verification>

<success_criteria>
- airev-core compiles with the new schema, types, and db functions
- Schema contains 4 tables (sessions, comments, file_review_state, threads) with UUID text PKs
- schema_version migration system works (migrate() idempotent — safe to call multiple times)
- All write paths use BEGIN IMMEDIATE
- uuid crate is in workspace dependencies
- Full workspace builds (airev binary may have unused-import warnings for old type fields, acceptable)
</success_criteria>

<output>
After completion, create `.planning/phases/04-persistence-layer/04-01-SUMMARY.md`
</output>
