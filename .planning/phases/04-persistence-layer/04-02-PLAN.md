---
phase: 04-persistence-layer
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - airev/src/event.rs
  - airev/src/app.rs
  - airev/src/main.rs
autonomous: true
requirements:
  - SQLite Persistence
  - Session lifecycle

must_haves:
  truths:
    - "AppEvent::DbResult carries a typed DbResultPayload (not a unit variant)"
    - "AppState holds db_conn, session, file_review_states, and event_tx fields"
    - "On startup, a session is detected or created before the first frame renders"
    - "File review state is loaded from DB before the first frame renders"
    - "DbResult match arm in main.rs applies ReviewToggled to AppState and triggers re-render"
    - "Session metadata is displayed in the status bar"
  artifacts:
    - path: "airev/src/event.rs"
      provides: "DbResultPayload enum and AppEvent::DbResult(Box<DbResultPayload>)"
      contains: "DbResultPayload"
    - path: "airev/src/app.rs"
      provides: "AppState with db_conn, session, file_review_states, event_tx fields"
      contains: "db_conn"
    - path: "airev/src/main.rs"
      provides: "Startup session lifecycle and DbResult event handling"
      contains: "detect_or_create_session"
  key_links:
    - from: "airev/src/main.rs"
      to: "airev-core/src/db.rs"
      via: "startup calls detect_or_create_session() and load_file_review_state()"
      pattern: "airev_core::db::detect_or_create_session"
    - from: "airev/src/main.rs"
      to: "airev/src/event.rs"
      via: "DbResult match arm destructures DbResultPayload"
      pattern: "DbResultPayload::ReviewToggled"
    - from: "airev/src/app.rs"
      to: "tokio_rusqlite::Connection"
      via: "db_conn field stores cloneable connection"
      pattern: "pub db_conn"
---

<objective>
Wire the persistence layer into the TUI: expand AppEvent::DbResult to carry typed payloads, add DB
fields to AppState, implement session detect-or-create at startup (before first frame), load
persisted file review state, handle DbResult events in the event loop, and display session info in
the status bar.

Purpose: After this plan, the TUI has a live session in the DB on every launch, persisted review
state is loaded into memory, and the event loop can process async DB result events — enabling
Plan 03 to wire the keybinding toggle and UI rendering.

Output: Updated event.rs, app.rs, main.rs with full DB integration.
</objective>

<execution_context>
@/Users/juliusalexandre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliusalexandre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-persistence-layer/04-RESEARCH.md
@.planning/phases/04-persistence-layer/04-01-SUMMARY.md
@airev/src/event.rs
@airev/src/app.rs
@airev/src/main.rs
@airev/src/ui/layout.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand AppEvent::DbResult to typed payload and add DB fields to AppState</name>
  <files>airev/src/event.rs, airev/src/app.rs</files>
  <action>
**event.rs changes:**

Add a `DbResultPayload` enum after the existing `AppEvent` enum:

```rust
/// Typed results from async DB operations, sent back over the event channel.
///
/// Follows the same Box<Payload> pattern as GitResultPayload — keeps AppEvent
/// variants pointer-sized on the channel regardless of payload size.
#[derive(Debug)]
pub enum DbResultPayload {
    /// A session was loaded (resumed) from the database.
    SessionLoaded(airev_core::types::Session),
    /// A new session was created in the database.
    SessionCreated(airev_core::types::Session),
    /// File review states loaded for the current session.
    FileReviewStateLoaded(Vec<(String, bool)>),
    /// A file's reviewed state was toggled.
    ReviewToggled { file_path: String, reviewed: bool },
}
```

Change the `DbResult` variant from unit to: `DbResult(Box<DbResultPayload>)`.

This change is backward-compatible: the existing `_ => {}` catch-all in main.rs handles unknown variant shapes, but the explicit `AppEvent::DbResult` will now need pattern-matching updates in main.rs (done in Task 2).

**app.rs changes:**

Add these imports at the top of app.rs:
```rust
use std::collections::HashMap;
use tokio::sync::mpsc::UnboundedSender;
```

Add new fields to `AppState` struct (after the existing `panel_rects` field, in a new "Phase 4: Persistence Layer fields" section):

```rust
// Phase 4: Persistence Layer fields

/// The tokio-rusqlite connection, cloneable for spawned async tasks.
///
/// `None` if the database failed to open at startup. Clone is cheap
/// (just an Arc increment) — clone into tokio::spawn closures freely.
pub db_conn: Option<tokio_rusqlite::Connection>,

/// The current review session loaded/created at startup.
///
/// `None` if no database is available. Contains session UUID, repo path,
/// diff mode, and timestamps.
pub session: Option<airev_core::types::Session>,

/// Per-file reviewed state for the current session.
///
/// Key is the file path (repo-relative), value is whether the file is marked
/// as reviewed. Populated from DB at startup, updated on toggle.
pub file_review_states: HashMap<String, bool>,

/// Sender for the unified event channel, used by spawned async DB tasks
/// to send results back to the event loop.
///
/// Follows the same pattern as `git_tx` — stored in AppState so
/// keybindings.rs can access it without extra parameters to handle_key().
pub event_tx: Option<UnboundedSender<crate::event::AppEvent>>,
```

Update the `Default` impl to initialize these fields:
```rust
db_conn: None,
session: None,
file_review_states: HashMap::new(),
event_tx: None,
```

Add a method to AppState for applying DB results:

```rust
/// Applies a DbResultPayload to AppState.
///
/// Called from the AppEvent::DbResult arm in main.rs. Updates session
/// and file review state based on the payload variant.
pub fn apply_db_result(&mut self, payload: crate::event::DbResultPayload) {
    match payload {
        crate::event::DbResultPayload::SessionLoaded(session)
        | crate::event::DbResultPayload::SessionCreated(session) => {
            self.session = Some(session);
        }
        crate::event::DbResultPayload::FileReviewStateLoaded(states) => {
            self.file_review_states = states.into_iter().collect();
        }
        crate::event::DbResultPayload::ReviewToggled { file_path, reviewed } => {
            self.file_review_states.insert(file_path, reviewed);
        }
    }
}
```

Also add a helper method for getting the current file path (used by keybindings):

```rust
/// Returns the repo-relative path of the currently selected file, if any.
///
/// Looks up `selected_file_index` in `file_summaries`. Returns `None` if
/// no files are loaded or the index is out of bounds.
pub fn current_file_path(&self) -> Option<&str> {
    self.file_list_state
        .selected()
        .and_then(|idx| self.file_summaries.get(idx))
        .map(|f| f.path.as_str())
}
```
  </action>
  <verify>`cargo build -p airev 2>&1 | tail -10` — should compile (main.rs catch-all handles the expanded DbResult variant). `grep "DbResultPayload" airev/src/event.rs | wc -l` returns at least 2. `grep "db_conn" airev/src/app.rs | wc -l` returns at least 2.</verify>
  <done>event.rs has DbResultPayload enum with 4 variants and AppEvent::DbResult(Box<DbResultPayload>). app.rs has db_conn, session, file_review_states, event_tx fields and apply_db_result() method. Workspace compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Wire startup session lifecycle and DbResult event handling in main.rs</name>
  <files>airev/src/main.rs, airev/src/ui/layout.rs</files>
  <action>
**main.rs changes:**

1. **Store event_tx in AppState** — after `let handler = event::EventHandler::new();` and before `event::spawn_event_task(handler.tx.clone());`, add:
   ```rust
   state.event_tx = Some(handler.tx.clone());
   ```

2. **Replace the `_db` binding with proper session lifecycle** — replace the existing Step 5 block:
   ```rust
   // Step 5: open the WAL-mode SQLite database before drawing the first frame.
   std::fs::create_dir_all(".airev")?;
   let _db = airev_core::db::open_db(".airev/reviews.db")
       .await
       .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
   ```

   With:
   ```rust
   // Step 5: open DB, detect/create session, load review state — all before first frame.
   // Requirements: "no loading spinner; all reads complete before the first frame."
   std::fs::create_dir_all(".airev")?;
   let db_conn = airev_core::db::open_db(".airev/reviews.db")
       .await
       .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

   // Detect or create session for this repo + diff mode combination.
   // The repo_path comes from git2::Repository::discover (computed in Step 6).
   // We need repo_path before session detection, so move git discovery before DB session.
   ```

   **Important restructuring:** The current code discovers the git repo in Step 6 (after DB open). We need the repo path for session detection. Restructure so that git repo discovery happens BEFORE session lifecycle:

   - Move the `maybe_repo_path` detection block (current Step 6 lines) to happen right after `std::fs::create_dir_all(".airev")?;` but BEFORE `open_db`.
   - Then open DB.
   - Then call `detect_or_create_session()` using `repo_path` (default to `"."` if no git repo).
   - Then call `load_file_review_state()`.
   - Store `db_conn`, `session`, and `file_review_states` in `state`.

   The revised Step 5-6 sequence should be:

   ```rust
   // Step 5: discover git repository (needed for session detection in Step 6).
   let maybe_repo_path: Option<String> = git2::Repository::discover(".")
       .ok()
       .and_then(|r| {
           r.workdir()
               .or_else(|| Some(r.path()))
               .map(|p| p.to_string_lossy().into_owned())
       });
   let repo_path_for_session = maybe_repo_path.as_deref().unwrap_or(".");

   // Step 6: open DB, detect/create session, load review state — all before first frame.
   std::fs::create_dir_all(".airev")?;
   let db_conn = airev_core::db::open_db(".airev/reviews.db")
       .await
       .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

   let diff_mode_str = format!("{:?}", state.diff_mode);
   let session = airev_core::db::detect_or_create_session(
       &db_conn, repo_path_for_session, &diff_mode_str, "",
   )
   .await
   .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

   let review_states = airev_core::db::load_file_review_state(&db_conn, &session.id)
       .await
       .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;

   state.db_conn = Some(db_conn);
   state.file_review_states = review_states.into_iter().collect();
   state.session = Some(session);

   // Step 7: spawn AsyncGit background thread (was Step 6).
   let maybe_git: Option<crate::git::AsyncGit> = maybe_repo_path.map(|path| {
       // ... (keep existing code unchanged)
   });
   ```

   Renumber subsequent steps in comments accordingly.

3. **Add DbResult match arm to the event loop** — in the `maybe_event` match block, add a new arm before the `_ => {}` catch-all:

   ```rust
   Some(event::AppEvent::DbResult(payload)) => {
       state.apply_db_result(*payload);
       // Trigger immediate redraw after DB state change.
       handler.tx.send(event::AppEvent::Render).ok();
   }
   ```

**layout.rs changes (status bar session info):**

In `render_status_bar()`, after the file count span block, add a session info span:

```rust
// Show session info when a session is active.
if let Some(ref session) = state.session {
    spans.push(Span::raw("  |  "));
    let session_label = format!("Session: {}...", &session.id[..8]);
    spans.push(Span::styled(session_label, Style::default().fg(Color::DarkGray)));
}
```

This shows the first 8 characters of the session UUID in the status bar (enough to identify, not too long). The `state.session` field is read-only here — no import changes needed since `AppState` is already passed as `&AppState`.
  </action>
  <verify>`cargo build --workspace 2>&1 | tail -10` shows no errors. Run `cargo run -p airev 2>/dev/null` briefly (Ctrl-C after 2 seconds) and then check `sqlite3 .airev/reviews.db "SELECT id, repo_path, diff_mode FROM sessions;"` returns one row with a UUID-format id. `grep "detect_or_create_session" airev/src/main.rs | wc -l` returns 1. `grep "DbResult" airev/src/main.rs | wc -l` returns at least 1 (the match arm).</verify>
  <done>main.rs creates/resumes a session before the first frame, loads file review state, stores db_conn and session in AppState, and handles DbResult events. Status bar shows session UUID prefix. Running the TUI creates a session row in reviews.db.</done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds with zero errors
2. Launch `airev` in a git repo, immediately quit with `q`, then: `sqlite3 .airev/reviews.db "SELECT id, repo_path FROM sessions;"` returns one row with a UUID
3. Launch `airev` again in the same repo, quit, then: `sqlite3 .airev/reviews.db "SELECT COUNT(*) FROM sessions;"` returns 1 (session was resumed, not duplicated)
4. `sqlite3 .airev/reviews.db "SELECT * FROM schema_version;"` returns `1`
5. `sqlite3 .airev/reviews.db "SELECT * FROM threads;"` returns empty result (table exists, no rows)
6. Status bar shows "Session: xxxxxxxx..." during TUI operation
</verification>

<success_criteria>
- AppEvent::DbResult carries typed DbResultPayload (no longer a unit variant)
- AppState has db_conn, session, file_review_states, and event_tx fields
- Session is created on first launch, resumed on subsequent launches (same repo+mode)
- File review state is loaded from DB before first frame
- DbResult event arm applies state updates and triggers re-render
- Status bar displays session UUID prefix
- Database file at .airev/reviews.db has correct v1 schema
</success_criteria>

<output>
After completion, create `.planning/phases/04-persistence-layer/04-02-SUMMARY.md`
</output>
